import numpy as np                                                              # Imports NumPy library as np
import matplotlib.pyplot as plt                                                 # Imports MatPlotLib.pyplot as plt
from matplotlib.gridspec import GridSpec                                        # Imports GridSpec submdodule of MatPlotLib
import matplotlib.patches as patches                                            # Imports the patches submodule of MatPlotLib

def initialize_lattice(size):                                                   # Defines the initial square lattice (size * size)
    lattice = np.zeros((size, size), dtype=int)
    return lattice

def compute_neighbor_indices_hex(size):
    neighbor_indices = {}
    for x in range(size):
        for y in range(size):
            neighbors = [
                ((x - 1) % size, y),
                ((x + 1) % size, y),
                (x, (y - 1) % size),
                (x, (y + 1) % size)
            ]
            if y % 2 == 0:
                neighbors.append(((x + 1) % size, (y - 1) % size))
                neighbors.append(((x + 1) % size, (y + 1) % size))
            else:
                neighbors.append(((x - 1) % size, (y - 1) % size))
                neighbors.append(((x - 1) % size, (y + 1) % size))

            neighbor_indices[(x, y)] = neighbors
    return neighbor_indices

def calculate_interaction_energy(lattice, site, particle, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH):
    x, y = site
    interaction_energy = 0
    for neighbor_coords in neighbor_indices[(x, y)]:
        neighbor_particle = lattice[neighbor_coords]
        if neighbor_particle != 0:
            if particle == 1:
                if neighbor_particle == 1:
                    interaction_energy += epsilon_NN
                else:
                    interaction_energy += epsilon_NH
            else:
                if neighbor_particle == 2:
                    interaction_energy += epsilon_HH
                else:
                    interaction_energy += epsilon_NH
    return interaction_energy


def attempt_move(lattice, N_N, N_H, N_empty, neighbor_indices, params):
    size = lattice.shape[0]
    N_sites = size * size
    beta = 1 / params['T']
    epsilon_N = params['epsilon_N']
    epsilon_H = params['epsilon_H']
    epsilon_NN = params['epsilon_NN']
    epsilon_HH = params['epsilon_HH']
    epsilon_NH = params['epsilon_NH']
    mu_N = params['mu_N']
    mu_H = params['mu_H']

    if np.random.rand() < 0.5:
        if N_empty == 0:
            return N_N, N_H, N_empty

        empty_sites_coords = np.argwhere(lattice == 0)
        chosen_idx = np.random.randint(0, len(empty_sites_coords))
        site = tuple(empty_sites_coords[chosen_idx])

        if np.random.rand() < 0.5:
            particle = 1
            mu = mu_N
            epsilon_adsorption = epsilon_N
            N_s = N_N
        else:
            particle = 2
            mu = mu_H
            epsilon_adsorption = epsilon_H
            N_s = N_H

        interaction_energy = calculate_interaction_energy(lattice, site, particle, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH)
        delta_E = epsilon_adsorption + interaction_energy

        acc_prob = min(1.0, (N_empty) / (N_s + 1) * np.exp(-beta * (delta_E - mu)))

        if np.random.rand() < acc_prob:
            lattice[site] = particle
            if particle == 1:
                N_N += 1
            else:
                N_H += 1
            N_empty -= 1
    else:
        if N_N + N_H == 0:
            return N_N, N_H, N_empty

        occupied_sites_coords = np.argwhere(lattice != 0)
        chosen_idx = np.random.randint(0, len(occupied_sites_coords))
        site = tuple(occupied_sites_coords[chosen_idx])

        particle = lattice[site]
        if particle == 1:
            mu = mu_N
            epsilon_adsorption = epsilon_N
            N_s = N_N
        else:
            mu = mu_H
            epsilon_adsorption = epsilon_H
            N_s = N_H

        interaction_energy = calculate_interaction_energy(lattice, site, particle, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH)
        delta_E = -(epsilon_adsorption + interaction_energy)

        acc_prob = min(1.0, N_s / (N_empty + 1) * np.exp(-beta * (delta_E + mu)))

        if np.random.rand() < acc_prob:
            lattice[site] = 0
            if particle == 1:
                N_N -= 1
            else:
                N_H -= 1
            N_empty += 1

    return N_N, N_H, N_empty

def run_simulation(size, n_steps, params):
    lattice = initialize_lattice(size)
    neighbor_indices = compute_neighbor_indices_hex(size)
    N_sites = size * size
    N_N = 0
    N_H = 0
    N_empty = N_sites
    coverage_N = np.zeros(n_steps)
    coverage_H = np.zeros(n_steps)

    for step in range(n_steps):
        N_N, N_H, N_empty = attempt_move(lattice, N_N, N_H, N_empty, neighbor_indices, params)
        coverage_N[step] = N_N / N_sites
        coverage_H[step] = N_H / N_sites

    return lattice, coverage_N, coverage_H

def plot_hex_lattice(lattice, ax, title):
    size = lattice.shape[0]
    width = size + 0.5
    height = size * 0.75 + 0.25

    ax.set_xlim(-0.5, width)
    ax.set_ylim(-0.5, height)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_aspect('equal', adjustable='box')
    ax.set_title(title)

    hex_radius = 0.45

    for col in range(size):
        for row in range(size):
            x_center = col + 0.5 + 0.5 * (row % 2)
            y_center = row * 0.75 + 0.5

            hexagon = patches.RegularPolygon((x_center, y_center), numVertices=6, radius=hex_radius,
                                             orientation=np.radians(0), facecolor='white', edgecolor='lightgray', linewidth=0.5)
            ax.add_patch(hexagon)

            if lattice[col, row] == 1:  # Particle N
                ax.plot(x_center, y_center, 'o', color='blue', markersize=18)
                ax.text(x_center, y_center, 'N', ha='center', va='center', color='white', fontsize=12, fontweight='bold')
            elif lattice[col, row] == 2:  # Particle H
                ax.plot(x_center, y_center, 'o', color='red', markersize=18)
                ax.text(x_center, y_center, 'H', ha='center', va='center', color='white', fontsize=12, fontweight='bold')
    return ax

# Parameters
size = 4
n_steps = 10000
mus_N = np.linspace(-0.2, 0, 7)
Ts = np.linspace(0.001, 0.019, 7)
params = []
for mu_N_val in mus_N:
    for T in Ts:
        params.append({
            'epsilon_N': -0.1,
            'epsilon_H': -0.1,
            'epsilon_NN': 0,
            'epsilon_HH': 0,
            'epsilon_NH': 0,
            'mu_N': mu_N_val,
            'mu_H': -0.1,
            'T': T
        })

np.random.seed(42)

final_lattice = np.zeros((len(mus_N), len(Ts), size, size), dtype=int)
mean_coverage_N = np.zeros((len(mus_N), len(Ts)))
mean_coverage_H = np.zeros((len(mus_N), len(Ts)))

for i, param in enumerate(params):
    lattice, coverage_N, coverage_H = run_simulation(size, n_steps, param)

    mu_N_idx = i // len(Ts)                                                     # Stores Results
    T_idx = i % len(Ts)
    final_lattice[mu_N_idx, T_idx] = lattice
    mean_coverage_N[mu_N_idx, T_idx] = np.mean(coverage_N[-1000:])
    mean_coverage_H[mu_N_idx, T_idx] = np.mean(coverage_H[-1000:])

fig = plt.figure(figsize=(10, 8), layout='constrained')
gs = GridSpec(2, 3, figure=fig, height_ratios=[1, 1])

fig.text(0.5, 1.0, 'Ideal Mixture of N and H in Hexagonal Lattice - Phase Diagram', ha='center', va='bottom', fontsize=14)
fig.text(0.5, 0.42, 'Ideal Mixture of N and H in Hexagonal Lattice - Lattice', ha='center', va='bottom', fontsize=14)

ax_N_coverage = fig.add_subplot(gs[0, 0])
ax_H_coverage = fig.add_subplot(gs[0, 1])
ax_Total_coverage = fig.add_subplot(gs[0, 2])
ax_lattice_03 = fig.add_subplot(gs[1, 0])
ax_lattice_33 = fig.add_subplot(gs[1, 1])
ax_lattice_63 = fig.add_subplot(gs[1, 2])

# Subplot for mean coverage of N
ax_N_coverage.pcolormesh(mus_N, Ts, mean_coverage_N.T, cmap='viridis', vmin=0, vmax=1)
ax_N_coverage.set_title(r'$\langle \theta_N \rangle$')
ax_N_coverage.set_xlabel(r'$\mu_N$')
ax_N_coverage.set_ylabel(r'$T$')

# Subplot for mean coverage of H
ax_H_coverage.pcolormesh(mus_N, Ts, mean_coverage_H.T, cmap='viridis', vmin=0, vmax=1)
ax_H_coverage.set_title(r'$\langle \theta_H \rangle$')
ax_H_coverage.set_xlabel(r'$\mu_N$')
ax_H_coverage.set_yticks([])

# Subplot for mean total coverage
cax = ax_Total_coverage.pcolormesh(mus_N, Ts, mean_coverage_N.T + mean_coverage_H.T, cmap='viridis', vmin=0, vmax=1)
ax_Total_coverage.set_title(r'$\langle \theta_N + \theta_H \rangle$')
ax_Total_coverage.set_xlabel(r'$\mu_N$')
ax_Total_coverage.set_yticks([])
fig.colorbar(cax, ax=ax_Total_coverage, location='right', fraction=0.1, pad=0.04)

# Hexagonal lattice grids
plot_hex_lattice(final_lattice[0, 3], ax_lattice_03, r'$\mu_N = -0.2$ eV, $T = 0.01 / k$')
plot_hex_lattice(final_lattice[3, 3], ax_lattice_33, r'$\mu_N = -0.1$ eV, $T = 0.01 / k$')
plot_hex_lattice(final_lattice[6, 3], ax_lattice_63, r'$\mu_N = 0$ eV, $T = 0.01 / k$')

plt.show()
