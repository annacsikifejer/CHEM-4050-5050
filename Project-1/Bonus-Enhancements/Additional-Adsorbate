import numpy as np                                                              # Imports NumPy library as np
import matplotlib.pyplot as plt                                                 # Imports MatPlotLib.pyplot as plt
from matplotlib.gridspec import GridSpec                                        # Imports GridSpec submdodule of MatPlotLib

def initialize_lattice(size):                                                   # Defines the initial square lattice (size * size)
    lattice = np.zeros((size, size), dtype=int)
    return lattice

def compute_neighbor_indices(size):
    neighbor_indices = {}
    for x in range(size):
        for y in range(size):
            neighbors = [
                ((x - 1) % size, y),
                ((x + 1) % size, y),
                (x, (y - 1) % size),
                (x, (y + 1) % size)
            ]
            neighbor_indices[(x, y)] = neighbors
    return neighbor_indices

def calculate_interaction_energy(lattice, site, particle, neighbor_indices,     # Adds C atom as additional adsorbate
                                 epsilon_NN, epsilon_HH, epsilon_NH,
                                 epsilon_NC, epsilon_HC, epsilon_CC):
    x, y = site
    interaction_energy = 0
    for neighbor_coords in neighbor_indices[(x, y)]:
        neighbor_particle = lattice[neighbor_coords]
        if neighbor_particle != 0:
            if particle == 1:
                if neighbor_particle == 1:
                    interaction_energy += epsilon_NN
                elif neighbor_particle == 2:
                    interaction_energy += epsilon_NH
                elif neighbor_particle == 3:
                    interaction_energy += epsilon_NC
            elif particle == 2:  # Particle H
                if neighbor_particle == 1: # Neighbor is Particle N
                    interaction_energy += epsilon_NH
                elif neighbor_particle == 2:
                    interaction_energy += epsilon_HH
                elif neighbor_particle == 3: # Neighbor is Particle C
                    interaction_energy += epsilon_HC
            elif particle == 3: # Particle C
                if neighbor_particle == 1: # Neighbor is Particle N
                    interaction_energy += epsilon_NC
                elif neighbor_particle == 2: # Neighbor is Particle H
                    interaction_energy += epsilon_HC
                elif neighbor_particle == 3: # Neighbor is Particle C
                    interaction_energy += epsilon_CC
    return interaction_energy


def attempt_move(lattice, N_N, N_H, N_C, N_empty, neighbor_indices, params):
    size = lattice.shape[0]
    N_sites = size * size
    beta = 1 / params['T']
    epsilon_N = params['epsilon_N']
    epsilon_H = params['epsilon_H']
    epsilon_C = params['epsilon_C'] # New
    epsilon_NN = params['epsilon_NN']
    epsilon_HH = params['epsilon_HH']
    epsilon_NH = params['epsilon_NH']
    epsilon_NC = params['epsilon_NC']
    epsilon_HC = params['epsilon_HC']
    epsilon_CC = params['epsilon_CC']
    mu_N = params['mu_N']
    mu_H = params['mu_H']
    mu_C = params['mu_C'] # New

    if np.random.rand() < 0.5:  # Decide whether to add or remove a particle (50% chance each)
        # IF adding a particle:
        if N_empty == 0:
            return N_N, N_H, N_C, N_empty  # No empty sites available

        empty_sites_coords = np.argwhere(lattice == 0)
        chosen_idx = np.random.randint(0, len(empty_sites_coords))
        site = tuple(empty_sites_coords[chosen_idx])

        r_particle_type = np.random.rand()
        if r_particle_type < 1/3:
            particle = 1
            mu = mu_N
            epsilon_adsorption = epsilon_N
            N_s = N_N
        elif r_particle_type < 2/3:
            particle = 2
            mu = mu_H
            epsilon_adsorption = epsilon_H
            N_s = N_H
        else:
            particle = 3
            mu = mu_C
            epsilon_adsorption = epsilon_C
            N_s = N_C

        interaction_energy = calculate_interaction_energy(lattice, site, particle, neighbor_indices,
                                                         epsilon_NN, epsilon_HH, epsilon_NH,
                                                         epsilon_NC, epsilon_HC, epsilon_CC)
        delta_E = epsilon_adsorption + interaction_energy

        acc_prob = min(1.0, (N_empty) / (N_s + 1) * np.exp(-beta * (delta_E - mu)))

        if np.random.rand() < acc_prob:
            lattice[site] = particle
            if particle == 1:
                N_N += 1
            elif particle == 2:
                N_H += 1
            else:
                N_C += 1
            N_empty -= 1
    else:
        if N_N + N_H + N_C == 0:
            return N_N, N_H, N_C, N_empty

        occupied_sites_coords = np.argwhere(lattice != 0)
        chosen_idx = np.random.randint(0, len(occupied_sites_coords))
        site = tuple(occupied_sites_coords[chosen_idx])

        particle = lattice[site]
        if particle == 1:
            mu = mu_N
            epsilon_adsorption = epsilon_N
            N_s = N_N
        elif particle == 2:
            mu = mu_H
            epsilon_adsorption = epsilon_H
            N_s = N_H
        else:
            mu = mu_C
            epsilon_adsorption = epsilon_C
            N_s = N_C

        interaction_energy = calculate_interaction_energy(lattice, site, particle, neighbor_indices,
                                                         epsilon_NN, epsilon_HH, epsilon_NH,
                                                         epsilon_NC, epsilon_HC, epsilon_CC)
        delta_E = -(epsilon_adsorption + interaction_energy)

        acc_prob = min(1.0, N_s / (N_empty + 1) * np.exp(-beta * (delta_E + mu)))

        if np.random.rand() < acc_prob:
            lattice[site] = 0
            if particle == 1:
                N_N -= 1
            elif particle == 2:
                N_H -= 1
            else:
                N_C -= 1
            N_empty += 1

    return N_N, N_H, N_C, N_empty

def run_simulation(size, n_steps, params):
    lattice = initialize_lattice(size)
    neighbor_indices = compute_neighbor_indices(size)
    N_sites = size * size
    N_N = 0
    N_H = 0
    N_C = 0
    N_empty = N_sites
    coverage_N = np.zeros(n_steps)
    coverage_H = np.zeros(n_steps)
    coverage_C = np.zeros(n_steps)

    for step in range(n_steps):
        N_N, N_H, N_C, N_empty = attempt_move(lattice, N_N, N_H, N_C, N_empty, neighbor_indices, params)
        coverage_N[step] = N_N / N_sites
        coverage_H[step] = N_H / N_sites
        coverage_C[step] = N_C / N_sites

    return lattice, coverage_N, coverage_H, coverage_C

def plot_lattice(lattice, ax, title):
    size = lattice.shape[0]
    ax.set_xlim(0, size)
    ax.set_ylim(0, size)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_aspect('equal', adjustable='box')
    ax.set_title(title)

    for i in range(size + 1):
        ax.plot([i, i], [0, size], color='lightgray', linewidth=0.5)
        ax.plot([0, size], [i, i], color='lightgray', linewidth=0.5)

    for x in range(size):
        for y in range(size):
            if lattice[x, y] == 1:
                ax.plot(x + 0.5, y + 0.5, 'o', color='blue', markersize=30)
                ax.text(x + 0.5, y + 0.5, 'N', ha='center', va='center', color='white', fontsize=12, fontweight='bold')
            elif lattice[x, y] == 2:
                ax.plot(x + 0.5, y + 0.5, 'o', color='red', markersize=30)
                ax.text(x + 0.5, y + 0.5, 'H', ha='center', va='center', color='white', fontsize=12, fontweight='bold')
            elif lattice[x, y] == 3:
                ax.plot(x + 0.5, y + 0.5, 'o', color='green', markersize=30)
                ax.text(x + 0.5, y + 0.5, 'C', ha='center', va='center', color='white', fontsize=12, fontweight='bold')
    return ax

# Parameters
size = 4
n_steps = 10000
mus_N = np.linspace(-0.2, 0, 7)
Ts = np.linspace(0.001, 0.019, 7)
params_list = []
for mu_N_val in mus_N:
    for T in Ts:
        params_list.append({
            'epsilon_N': -0.1,
            'epsilon_H': -0.1,
            'epsilon_C': -0.1,
            'epsilon_NN': 0,
            'epsilon_HH': 0,
            'epsilon_NH': 0,
            'epsilon_NC': 0,
            'epsilon_HC': 0,
            'epsilon_CC': 0,
            'mu_N': mu_N_val,
            'mu_H': -0.1,
            'mu_C': -0.1,
            'T': T
        })

np.random.seed(42)

final_lattice = np.zeros((len(mus_N), len(Ts), size, size), dtype=int)
mean_coverage_N = np.zeros((len(mus_N), len(Ts)))
mean_coverage_H = np.zeros((len(mus_N), len(Ts)))
mean_coverage_C = np.zeros((len(mus_N), len(Ts)))

for i, param in enumerate(params_list):
    lattice, coverage_N, coverage_H, coverage_C = run_simulation(size, n_steps, param)

    mu_N_idx = i // len(Ts)
    T_idx = i % len(Ts)
    final_lattice[mu_N_idx, T_idx] = lattice
    mean_coverage_N[mu_N_idx, T_idx] = np.mean(coverage_N[-1000:])
    mean_coverage_H[mu_N_idx, T_idx] = np.mean(coverage_H[-1000:])
    mean_coverage_C[mu_N_idx, T_idx] = np.mean(coverage_C[-1000:])

fig = plt.figure(figsize=(15, 8), layout='constrained')
gs = GridSpec(2, 4, figure=fig, height_ratios=[1, 1])

fig.text(0.5, 1.0, 'Ideal Mixture of N and H with Additional Adsorbate C - Phase Diagram', ha='center', va='bottom', fontsize=14)
fig.text(0.5, 0.43, 'Ideal Mixture of N and H with Additional Adsorbate C - Lattice', ha='center', va='bottom', fontsize=14)

ax_N_coverage = fig.add_subplot(gs[0, 0])
ax_H_coverage = fig.add_subplot(gs[0, 1])
ax_C_coverage = fig.add_subplot(gs[0, 2])
ax_Total_coverage = fig.add_subplot(gs[0, 3])
ax_lattice_03 = fig.add_subplot(gs[1, 0])
ax_lattice_33 = fig.add_subplot(gs[1, 1])
ax_lattice_63 = fig.add_subplot(gs[1, 2])

# Subplot for mean coverage of N
ax_N_coverage.pcolormesh(mus_N, Ts, mean_coverage_N.T, cmap='viridis', vmin=0, vmax=1)
ax_N_coverage.set_title(r'$\langle \theta_N \rangle$')
ax_N_coverage.set_xlabel(r'$\mu_N$')
ax_N_coverage.set_ylabel(r'$T$')

# Subplot for mean coverage of H
ax_H_coverage.pcolormesh(mus_N, Ts, mean_coverage_H.T, cmap='viridis', vmin=0, vmax=1)
ax_H_coverage.set_title(r'$\langle \theta_H \rangle$')
ax_H_coverage.set_xlabel(r'$\mu_N$')
ax_H_coverage.set_ylabel(r'$T$')

# Subplot for mean coverage of C (New)
ax_C_coverage.pcolormesh(mus_N, Ts, mean_coverage_C.T, cmap='viridis', vmin=0, vmax=1)
ax_C_coverage.set_title(r'$\langle \theta_C \rangle$')
ax_C_coverage.set_xlabel(r'$\mu_N$')
ax_C_coverage.set_ylabel(r'$T$')

# Subplot for mean total coverage
cax = ax_Total_coverage.pcolormesh(mus_N, Ts, (mean_coverage_N + mean_coverage_H + mean_coverage_C).T, cmap='viridis', vmin=0, vmax=1)
ax_Total_coverage.set_title(r'$\langle \theta_N + \theta_H + \theta_C \rangle$')
ax_Total_coverage.set_xlabel(r'$\mu_N$')
ax_Total_coverage.set_ylabel(r'$T$')
fig.colorbar(cax, ax=ax_Total_coverage, location='right', fraction=0.1, pad=0.04)

plot_lattice(final_lattice[0, 3], ax_lattice_03, r'$\mu_N = -0.2$ eV, $T = 0.01 / k$')
plot_lattice(final_lattice[3, 3], ax_lattice_33, r'$\mu_N = -0.1$ eV, $T = 0.01 / k$')
plot_lattice(final_lattice[6, 3], ax_lattice_63, r'$\mu_N = 0$ eV, $T = 0.01 / k$')

plt.show()
