# Additional Adsorbate

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec

def initialize_lattice(size):
    lattice = np.zeros((size, size), dtype=int)
    return lattice

def compute_neighbor_indices(size):
    neighbor_indices = {}
    for x in range(size):
        for y in range(size):
            neighbors = [
                ((x - 1) % size, y),
                ((x + 1) % size, y),
                (x, (y - 1) % size),
                (x, (y + 1) % size)
            ]
            neighbor_indices[(x, y)] = neighbors
    return neighbor_indices

# Modified function to include C particles and their interactions
def calculate_interaction_energy(lattice, site, particle, neighbor_indices,
                                 epsilon_NN, epsilon_HH, epsilon_NH,
                                 epsilon_NC, epsilon_HC, epsilon_CC):
    x, y = site
    interaction_energy = 0
    for neighbor_coords in neighbor_indices[(x, y)]:
        neighbor_particle = lattice[neighbor_coords]
        if neighbor_particle != 0:
            if particle == 1:  # Particle N
                if neighbor_particle == 1:
                    interaction_energy += epsilon_NN
                elif neighbor_particle == 2:  # Neighbor is Particle H
                    interaction_energy += epsilon_NH
                elif neighbor_particle == 3: # Neighbor is Particle C
                    interaction_energy += epsilon_NC
            elif particle == 2:  # Particle H
                if neighbor_particle == 1: # Neighbor is Particle N
                    interaction_energy += epsilon_NH
                elif neighbor_particle == 2:
                    interaction_energy += epsilon_HH
                elif neighbor_particle == 3: # Neighbor is Particle C
                    interaction_energy += epsilon_HC
            elif particle == 3: # Particle C
                if neighbor_particle == 1: # Neighbor is Particle N
                    interaction_energy += epsilon_NC
                elif neighbor_particle == 2: # Neighbor is Particle H
                    interaction_energy += epsilon_HC
                elif neighbor_particle == 3: # Neighbor is Particle C
                    interaction_energy += epsilon_CC
    return interaction_energy


def attempt_move(lattice, N_N, N_H, N_C, N_empty, neighbor_indices, params):
    size = lattice.shape[0]
    N_sites = size * size
    beta = 1 / params['T']
    epsilon_N = params['epsilon_N']
    epsilon_H = params['epsilon_H']
    epsilon_C = params['epsilon_C'] # New
    epsilon_NN = params['epsilon_NN']
    epsilon_HH = params['epsilon_HH']
    epsilon_NH = params['epsilon_NH']
    epsilon_NC = params['epsilon_NC']
    epsilon_HC = params['epsilon_HC']
    epsilon_CC = params['epsilon_CC']
    mu_N = params['mu_N']
    mu_H = params['mu_H']
    mu_C = params['mu_C'] # New

    if np.random.rand() < 0.5:  # Decide whether to add or remove a particle (50% chance each)
        # IF adding a particle:
        if N_empty == 0:
            return N_N, N_H, N_C, N_empty  # No empty sites available

        empty_sites_coords = np.argwhere(lattice == 0)
        chosen_idx = np.random.randint(0, len(empty_sites_coords))
        site = tuple(empty_sites_coords[chosen_idx])

        # Decide which particle to add (N, H, or C) with equal probability
        r_particle_type = np.random.rand()
        if r_particle_type < 1/3:
            # IF adding Particle N:
            particle = 1
            mu = mu_N
            epsilon_adsorption = epsilon_N
            N_s = N_N
        elif r_particle_type < 2/3:
            # IF adding Particle H:
            particle = 2
            mu = mu_H
            epsilon_adsorption = epsilon_H
            N_s = N_H
        else: # Adding Particle C
            particle = 3
            mu = mu_C
            epsilon_adsorption = epsilon_C
            N_s = N_C

        # CALCULATE 'delta_E' = 'epsilon' + calculate_interaction_energy(...)
        interaction_energy = calculate_interaction_energy(lattice, site, particle, neighbor_indices,
                                                         epsilon_NN, epsilon_HH, epsilon_NH,
                                                         epsilon_NC, epsilon_HC, epsilon_CC)
        delta_E = epsilon_adsorption + interaction_energy

        # CALCULATE acceptance probability 'acc_prob' = MIN[1, (N_empty) / (N_s + 1) * np.exp(-beta * (delta_E - mu))]
        acc_prob = min(1.0, (N_empty) / (N_s + 1) * np.exp(-beta * (delta_E - mu)))

        # GENERATE a random number 'r' between 0 and 1
        # IF 'r' < 'acc_prob':
        if np.random.rand() < acc_prob:
            lattice[site] = particle
            # UPDATE counts:
            if particle == 1:
                N_N += 1
            elif particle == 2:
                N_H += 1
            else: # particle == 3
                N_C += 1
            N_empty -= 1
    else:  # Removing a particle
        if N_N + N_H + N_C == 0:  # No particles to remove
            return N_N, N_H, N_C, N_empty

        occupied_sites_coords = np.argwhere(lattice != 0)
        chosen_idx = np.random.randint(0, len(occupied_sites_coords))
        site = tuple(occupied_sites_coords[chosen_idx])

        particle = lattice[site]
        if particle == 1:
            mu = mu_N
            epsilon_adsorption = epsilon_N
            N_s = N_N
        elif particle == 2:  # Particle H
            mu = mu_H
            epsilon_adsorption = epsilon_H
            N_s = N_H
        else: # particle == 3 (Particle C)
            mu = mu_C
            epsilon_adsorption = epsilon_C
            N_s = N_C

        interaction_energy = calculate_interaction_energy(lattice, site, particle, neighbor_indices,
                                                         epsilon_NN, epsilon_HH, epsilon_NH,
                                                         epsilon_NC, epsilon_HC, epsilon_CC)
        delta_E = -(epsilon_adsorption + interaction_energy) # Energy change is negative of the energy it had

        acc_prob = min(1.0, N_s / (N_empty + 1) * np.exp(-beta * (delta_E + mu)))

        if np.random.rand() < acc_prob:
            lattice[site] = 0  # Remove particle
            if particle == 1:
                N_N -= 1
            elif particle == 2:
                N_H -= 1
            else: # particle == 3
                N_C -= 1
            N_empty += 1

    return N_N, N_H, N_C, N_empty

def run_simulation(size, n_steps, params):
    # INITIALIZE 'lattice' using initialize_lattice(size)
    lattice = initialize_lattice(size)
    # COMPUTE 'neighbor_indices' using compute_neighbor_indices(size)
    neighbor_indices = compute_neighbor_indices(size)
    N_sites = size * size
    # INITIALIZE counts:
    # 'N_N' = 0, 'N_H' = 0, 'N_C' = 0 (new)
    # 'N_empty' = 'N_sites'
    N_N = 0
    N_H = 0
    N_C = 0 # New
    N_empty = N_sites
    # CREATE arrays 'coverage_N', 'coverage_H', and 'coverage_C' (new) of length 'n_steps'
    coverage_N = np.zeros(n_steps)
    coverage_H = np.zeros(n_steps)
    coverage_C = np.zeros(n_steps) # New

    # FOR 'step' FROM 0 TO 'n_steps' - 1:
    for step in range(n_steps):
        # UPDATE 'N_N', 'N_H', 'N_C', 'N_empty' by calling attempt_move(...)
        N_N, N_H, N_C, N_empty = attempt_move(lattice, N_N, N_H, N_C, N_empty, neighbor_indices, params)
        # SET coverage_N[step] = 'N_N' / 'N_sites'
        coverage_N[step] = N_N / N_sites
        # SET coverage_H[step] = 'N_H' / 'N_sites'
        coverage_H[step] = N_H / N_sites
        # SET coverage_C[step] = 'N_C' / 'N_sites'
        coverage_C[step] = N_C / N_sites # New

    # RETURN 'lattice', 'coverage_N', 'coverage_H', 'coverage_C'
    return lattice, coverage_N, coverage_H, coverage_C

# Modified function to visualize C particles
def plot_lattice(lattice, ax, title):
    size = lattice.shape[0]  # Assuming square lattice
    ax.set_xlim(0, size)
    ax.set_ylim(0, size)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_aspect('equal', adjustable='box')  # Ensure squares are square
    ax.set_title(title)

    # Draw grid
    for i in range(size + 1):
        ax.plot([i, i], [0, size], color='lightgray', linewidth=0.5)
        ax.plot([0, size], [i, i], color='lightgray', linewidth=0.5)

    for x in range(size):
        for y in range(size):
            if lattice[x, y] == 1:  # Particle N
                ax.plot(x + 0.5, y + 0.5, 'o', color='blue', markersize=30) # Increased markersize
                ax.text(x + 0.5, y + 0.5, 'N', ha='center', va='center', color='white', fontsize=12, fontweight='bold')
            elif lattice[x, y] == 2:  # Particle H
                ax.plot(x + 0.5, y + 0.5, 'o', color='red', markersize=30) # Increased markersize
                ax.text(x + 0.5, y + 0.5, 'H', ha='center', va='center', color='white', fontsize=12, fontweight='bold')
            elif lattice[x, y] == 3:  # Particle C (New)
                ax.plot(x + 0.5, y + 0.5, 'o', color='green', markersize=30) # Distinct color
                ax.text(x + 0.5, y + 0.5, 'C', ha='center', va='center', color='white', fontsize=12, fontweight='bold') # Label
    return ax


# Parameters
size = 4
n_steps = 10000
mus_N = np.linspace(-0.2, 0, 7)
Ts = np.linspace(0.001, 0.019, 7)
params_list = [] # Renamed to avoid conflict with 'params' inside functions
for mu_N_val in mus_N:
    for T in Ts:
        params_list.append({
            'epsilon_N': -0.1,
            'epsilon_H': -0.1,
            'epsilon_C': -0.1, # New parameter for C adsorption
            'epsilon_NN': 0,
            'epsilon_HH': 0,
            'epsilon_NH': 0,
            'epsilon_NC': 0, # New interaction energy N-C
            'epsilon_HC': 0, # New interaction energy H-C
            'epsilon_CC': 0, # New interaction energy C-C
            'mu_N': mu_N_val,
            'mu_H': -0.1,
            'mu_C': -0.1, # New chemical potential for C
            'T': T  # Temperature (in units of k)
        })

# Run the simulation
np.random.seed(42)

# Pre-allocate arrays for results
final_lattice = np.zeros((len(mus_N), len(Ts), size, size), dtype=int)
mean_coverage_N = np.zeros((len(mus_N), len(Ts)))
mean_coverage_H = np.zeros((len(mus_N), len(Ts)))
mean_coverage_C = np.zeros((len(mus_N), len(Ts))) # New array for C coverage

# Loop through parameter combinations
for i, param in enumerate(params_list):
    # Updated return values from run_simulation
    lattice, coverage_N, coverage_H, coverage_C = run_simulation(size, n_steps, param)

    # Store results
    mu_N_idx = i // len(Ts)
    T_idx = i % len(Ts)
    final_lattice[mu_N_idx, T_idx] = lattice
    mean_coverage_N[mu_N_idx, T_idx] = np.mean(coverage_N[-1000:])
    mean_coverage_H[mu_N_idx, T_idx] = np.mean(coverage_H[-1000:])
    mean_coverage_C[mu_N_idx, T_idx] = np.mean(coverage_C[-1000:]) # Store mean C coverage

# Plotting using GridSpec to accommodate the new C coverage plot
fig = plt.figure(figsize=(15, 8), layout='constrained') # Increased figure size
gs = GridSpec(2, 4, figure=fig, height_ratios=[1, 1]) # Changed to 2x4 grid for C coverage

ax_N_coverage = fig.add_subplot(gs[0, 0])
ax_H_coverage = fig.add_subplot(gs[0, 1])
ax_C_coverage = fig.add_subplot(gs[0, 2]) # New subplot for C coverage
ax_Total_coverage = fig.add_subplot(gs[0, 3]) # Shifted index
ax_lattice_03 = fig.add_subplot(gs[1, 0])
ax_lattice_33 = fig.add_subplot(gs[1, 1])
ax_lattice_63 = fig.add_subplot(gs[1, 2])

# Subplot for mean coverage of N
ax_N_coverage.pcolormesh(mus_N, Ts, mean_coverage_N.T, cmap='viridis', vmin=0, vmax=1)
ax_N_coverage.set_title(r'$\langle \theta_N \rangle$')
ax_N_coverage.set_xlabel(r'$\mu_N$')
ax_N_coverage.set_ylabel(r'$T$')

# Subplot for mean coverage of H
ax_H_coverage.pcolormesh(mus_N, Ts, mean_coverage_H.T, cmap='viridis', vmin=0, vmax=1)
ax_H_coverage.set_title(r'$\langle \theta_H \rangle$')
ax_H_coverage.set_xlabel(r'$\mu_N$')
ax_H_coverage.set_ylabel(r'$T$') # Added ylabel for consistency

# Subplot for mean coverage of C (New)
ax_C_coverage.pcolormesh(mus_N, Ts, mean_coverage_C.T, cmap='viridis', vmin=0, vmax=1)
ax_C_coverage.set_title(r'$\langle \theta_C \rangle$')
ax_C_coverage.set_xlabel(r'$\mu_N$')
ax_C_coverage.set_ylabel(r'$T$') # Added ylabel for consistency

# Subplot for mean total coverage
cax = ax_Total_coverage.pcolormesh(mus_N, Ts, (mean_coverage_N + mean_coverage_H + mean_coverage_C).T, cmap='viridis', vmin=0, vmax=1) # Updated calculation
ax_Total_coverage.set_title(r'$\langle \theta_N + \theta_H + \theta_C \rangle$') # Updated title
ax_Total_coverage.set_xlabel(r'$\mu_N$')
ax_Total_coverage.set_ylabel(r'$T$') # Added ylabel for consistency
fig.colorbar(cax, ax=ax_Total_coverage, location='right', fraction=0.1, pad=0.04)

# Plot the final lattice configuration
# mu_N = -0.2 eV and T = 0.01 / k (index for mus_N is 0, for Ts is 3) -> 0, 3
plot_lattice(final_lattice[0, 3], ax_lattice_03, r'$\mu_N = -0.2$ eV, $T = 0.01 / k$')

# mu_N = -0.1 eV and T = 0.01 / k (index for mus_N is 3, for Ts is 3) -> 3, 3
plot_lattice(final_lattice[3, 3], ax_lattice_33, r'$\mu_N = -0.1$ eV, $T = 0.01 / k$')

# mu_N = 0 eV and T = 0.01 / k (index for mus_N is 6, for Ts is 3) -> 6, 3
plot_lattice(final_lattice[6, 3], ax_lattice_63, r'$\mu_N = 0$ eV, $T = 0.01 / k$')

plt.show()
