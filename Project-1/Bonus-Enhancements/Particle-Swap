# Particle Swap

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec

def initialize_lattice(size):
    lattice = np.zeros((size, size), dtype=int)
    return lattice

def compute_neighbor_indices(size):
    neighbor_indices = {}
    for x in range(size):
        for y in range(size):
            neighbors = [
                ((x - 1) % size, y),
                ((x + 1) % size, y),
                (x, (y - 1) % size),
                (x, (y + 1) % size)
            ]
            neighbor_indices[(x, y)] = neighbors
    return neighbor_indices

def calculate_interaction_energy(lattice, site, particle, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH):
    x, y = site
    interaction_energy = 0
    for neighbor_coords in neighbor_indices[(x, y)]:
        neighbor_particle = lattice[neighbor_coords]
        if neighbor_particle != 0:
            if particle == 1:  # Particle N
                if neighbor_particle == 1:
                    interaction_energy += epsilon_NN
                else:  # Neighbor is Particle H
                    interaction_energy += epsilon_NH
            else:  # Particle H
                if neighbor_particle == 2:
                    interaction_energy += epsilon_HH
                else:  # Neighbor is Particle N
                    interaction_energy += epsilon_NH
    return interaction_energy

def get_adsorption_energy(particle_type, params):
    if particle_type == 1:  # Particle N
        return params['epsilon_N']
    elif particle_type == 2:  # Particle H
        return params['epsilon_H']
    return 0.0  # Empty site has 0 adsorption energy

def attempt_move(lattice, N_N, N_H, N_empty, neighbor_indices, params):
    size = lattice.shape[0]
    N_sites = size * size
    beta = 1 / params['T']
    epsilon_N = params['epsilon_N']
    epsilon_H = params['epsilon_H']
    epsilon_NN = params['epsilon_NN']
    epsilon_HH = params['epsilon_HH']
    epsilon_NH = params['epsilon_NH']
    mu_N = params['mu_N']
    mu_H = params['mu_H']

    move_type_rand = np.random.rand()

    if move_type_rand < 1/3:  # Attempt to add a particle
        if N_empty == 0:
            return N_N, N_H, N_empty  # No empty sites available

        empty_sites_coords = np.argwhere(lattice == 0)
        chosen_idx = np.random.randint(0, len(empty_sites_coords))
        site = tuple(empty_sites_coords[chosen_idx])

        if np.random.rand() < 0.5:  # Decide which particle to add (N or H) with equal probability
            particle = 1 # Particle N
            mu = mu_N
            epsilon_adsorption = epsilon_N
            N_s = N_N
        else:  # Adding Particle H
            particle = 2
            mu = mu_H
            epsilon_adsorption = epsilon_H
            N_s = N_H

        interaction_energy = calculate_interaction_energy(lattice, site, particle, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH)
        delta_E = epsilon_adsorption + interaction_energy

        acc_prob = min(1.0, (N_empty) / (N_s + 1) * np.exp(-beta * (delta_E - mu)))

        if np.random.rand() < acc_prob:
            lattice[site] = particle
            if particle == 1:
                N_N += 1
            else:
                N_H += 1
            N_empty -= 1
    elif move_type_rand < 2/3:  # Attempt to remove a particle
        if N_N + N_H == 0:  # No particles to remove
            return N_N, N_H, N_empty

        occupied_sites_coords = np.argwhere(lattice != 0)
        chosen_idx = np.random.randint(0, len(occupied_sites_coords))
        site = tuple(occupied_sites_coords[chosen_idx])

        particle = lattice[site]
        if particle == 1:
            mu = mu_N
            epsilon_adsorption = epsilon_N
            N_s = N_N
        else:  # Particle H
            mu = mu_H
            epsilon_adsorption = epsilon_H
            N_s = N_H

        interaction_energy = calculate_interaction_energy(lattice, site, particle, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH)
        delta_E = -(epsilon_adsorption + interaction_energy) # Energy change is negative of the energy it had

        acc_prob = min(1.0, N_s / (N_empty + 1) * np.exp(-beta * (delta_E + mu)))

        if np.random.rand() < acc_prob:
            lattice[site] = 0  # Remove particle
            if particle == 1:
                N_N -= 1
            else:
                N_H -= 1
            N_empty += 1
    else:  # Attempt to swap particles
        if N_sites < 2: # Need at least two sites for a swap
            return N_N, N_H, N_empty

        # Select two distinct random sites
        site_indices = np.random.choice(N_sites, 2, replace=False)
        site1 = (site_indices[0] // size, site_indices[0] % size)
        site2 = (site_indices[1] // size, site_indices[1] % size)

        old_particle1 = lattice[site1]
        old_particle2 = lattice[site2]

        # If particles are identical, no change, so return
        if old_particle1 == old_particle2:
            return N_N, N_H, N_empty

        # Calculate total energy contribution before swap
        interaction_energy1_before = calculate_interaction_energy(lattice, site1, old_particle1, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH)
        adsorption_energy1_before = get_adsorption_energy(old_particle1, params)
        interaction_energy2_before = calculate_interaction_energy(lattice, site2, old_particle2, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH)
        adsorption_energy2_before = get_adsorption_energy(old_particle2, params)
        E_before = (adsorption_energy1_before + interaction_energy1_before) + \
                   (adsorption_energy2_before + interaction_energy2_before)

        # Create a temporary lattice with swapped particles to calculate after-swap interactions
        temp_lattice = np.copy(lattice)
        temp_lattice[site1] = old_particle2
        temp_lattice[site2] = old_particle1

        # Calculate total energy contribution after swap
        interaction_energy1_after = calculate_interaction_energy(temp_lattice, site1, old_particle2, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH)
        adsorption_energy1_after = get_adsorption_energy(old_particle2, params)
        interaction_energy2_after = calculate_interaction_energy(temp_lattice, site2, old_particle1, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH)
        adsorption_energy2_after = get_adsorption_energy(old_particle1, params)
        E_after = (adsorption_energy1_after + interaction_energy1_after) + \
                  (adsorption_energy2_after + interaction_energy2_after)

        delta_E_swap = E_after - E_before

        # Metropolis acceptance criterion for swap
        acc_prob_swap = min(1.0, np.exp(-beta * delta_E_swap))

        if np.random.rand() < acc_prob_swap:
            lattice[site1] = old_particle2
            lattice[site2] = old_particle1
            # N_N, N_H, N_empty counts do not change for a swap

    return N_N, N_H, N_empty

def run_simulation(size, n_steps, params):
    # INITIALIZE 'lattice' using initialize_lattice(size)
    lattice = initialize_lattice(size)
    # COMPUTE 'neighbor_indices' using compute_neighbor_indices(size)
    neighbor_indices = compute_neighbor_indices(size)
    N_sites = size * size
    # INITIALIZE counts:
    # 'N_N' = 0
    # 'N_H' = 0
    # 'N_empty' = 'N_sites'
    N_N = 0
    N_H = 0
    N_empty = N_sites
    # CREATE arrays 'coverage_N' and 'coverage_H' of length 'n_steps'
    coverage_N = np.zeros(n_steps)
    coverage_H = np.zeros(n_steps)

    # FOR 'step' FROM 0 TO 'n_steps' - 1:
    for step in range(n_steps):
        # UPDATE 'N_N', 'N_H', 'N_empty' by calling attempt_move(...)
        N_N, N_H, N_empty = attempt_move(lattice, N_N, N_H, N_empty, neighbor_indices, params)
        # SET coverage_N[step] = 'N_N' / 'N_sites'
        coverage_N[step] = N_N / N_sites
        # SET coverage_H[step] = 'N_H' / 'N_sites'
        coverage_H[step] = N_H / N_sites

    # RETURN 'lattice', 'coverage_N', 'coverage_H'
    return lattice, coverage_N, coverage_H

def plot_lattice(lattice, ax, title):
    size = lattice.shape[0]  # Assuming square lattice
    ax.set_xlim(0, size)
    ax.set_ylim(0, size)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_aspect('equal', adjustable='box')  # Ensure squares are square
    ax.set_title(title)

    # Draw grid
    for i in range(size + 1):
        ax.plot([i, i], [0, size], color='lightgray', linewidth=0.5)
        ax.plot([0, size], [i, i], color='lightgray', linewidth=0.5)

    for x in range(size):
        for y in range(size):
            if lattice[x, y] == 1:  # Particle N
                ax.plot(x + 0.5, y + 0.5, 'o', color='blue', markersize=30) # Increased markersize
                ax.text(x + 0.5, y + 0.5, 'N', ha='center', va='center', color='white', fontsize=12, fontweight='bold')
            elif lattice[x, y] == 2:  # Particle H
                ax.plot(x + 0.5, y + 0.5, 'o', color='red', markersize=30) # Increased markersize
                ax.text(x + 0.5, y + 0.5, 'H', ha='center', va='center', color='white', fontsize=12, fontweight='bold')
    return ax



# Parameters
size = 4
n_steps = 10000
mus_N = np.linspace(-0.2, 0, 7)
Ts = np.linspace(0.001, 0.019, 7)
params = []
for mu_N_val in mus_N:
    for T in Ts:
        params.append({
            'epsilon_N': -0.1,
            'epsilon_H': -0.1,
            'epsilon_NN': 0,
            'epsilon_HH': 0,
            'epsilon_NH': 0,
            'mu_N': mu_N_val,
            'mu_H': -0.1,
            'T': T  # Temperature (in units of k)
        })

# Run the simulation
np.random.seed(42)

# Pre-allocate arrays for results
final_lattice = np.zeros((len(mus_N), len(Ts), size, size), dtype=int)
mean_coverage_N = np.zeros((len(mus_N), len(Ts)))
mean_coverage_H = np.zeros((len(mus_N), len(Ts)))

# Loop through parameter combinations
for i, param in enumerate(params):
    lattice, coverage_N, coverage_H = run_simulation(size, n_steps, param)

    # Store results
    mu_N_idx = i // len(Ts)
    T_idx = i % len(Ts)
    final_lattice[mu_N_idx, T_idx] = lattice
    mean_coverage_N[mu_N_idx, T_idx] = np.mean(coverage_N[-1000:])
    mean_coverage_H[mu_N_idx, T_idx] = np.mean(coverage_H[-1000:])

# Plotting using GridSpec as an alternative to subplots_mosaic
fig = plt.figure(figsize=(10, 8), layout='constrained')
gs = GridSpec(2, 3, figure=fig, height_ratios=[1, 1])

ax_N_coverage = fig.add_subplot(gs[0, 0])
ax_H_coverage = fig.add_subplot(gs[0, 1])
ax_Total_coverage = fig.add_subplot(gs[0, 2])
ax_lattice_03 = fig.add_subplot(gs[1, 0])
ax_lattice_33 = fig.add_subplot(gs[1, 1])
ax_lattice_63 = fig.add_subplot(gs[1, 2])

# Subplot for mean coverage of N
ax_N_coverage.pcolormesh(mus_N, Ts, mean_coverage_N.T, cmap='viridis', vmin=0, vmax=1)
ax_N_coverage.set_title(r'$\/langle \theta_N \rangle$')
ax_N_coverage.set_xlabel(r'$\/mu_N$')
ax_N_coverage.set_ylabel(r'$T$')

# Subplot for mean coverage of H
ax_H_coverage.pcolormesh(mus_N, Ts, mean_coverage_H.T, cmap='viridis', vmin=0, vmax=1)
ax_H_coverage.set_title(r'$\/langle \theta_H \rangle$')
ax_H_coverage.set_xlabel(r'$\/mu_N$')
ax_H_coverage.set_yticks([])

# Subplot for mean total coverage
cax = ax_Total_coverage.pcolormesh(mus_N, Ts, mean_coverage_N.T + mean_coverage_H.T, cmap='viridis', vmin=0, vmax=1)
ax_Total_coverage.set_title(r'$\/langle \theta_N + \theta_H \rangle$')
ax_Total_coverage.set_xlabel(r'$\/mu_N$')
ax_Total_coverage.set_yticks([])
fig.colorbar(cax, ax=ax_Total_coverage, location='right', fraction=0.1, pad=0.04)

# Plot the final lattice configuration

# mu_N = -0.2 eV and T = 0.01 / k (index for mus_N is 0, for Ts is 3) -> 0, 3
plot_lattice(final_lattice[0, 3], ax_lattice_03, r'$\/mu_N = -0.2$ eV, $T = 0.01 / k$')

# mu_N = -0.1 eV and T = 0.01 / k (index for mus_N is 3, for Ts is 3) -> 3, 3
plot_lattice(final_lattice[3, 3], ax_lattice_33, r'$\/mu_N = -0.1$ eV, $T = 0.01 / k$')

# mu_N = 0 eV and T = 0.01 / k (index for mus_N is 6, for Ts is 3) -> 6, 3
plot_lattice(final_lattice[6, 3], ax_lattice_63, r'$\/mu_N = 0$ eV, $T = 0.01 / k$')

plt.show()
