import numpy as np                                                              # Imports NumPy library as np
import matplotlib.pyplot as plt                                                 # Imports MatPlotLib.pyplot as plt
from matplotlib.gridspec import GridSpec                                        # Imports GridSpec submdodule of MatPlotLib

def initialize_lattice(size):                                                   # Defines the initial square lattice (size * size)
    lattice = np.zeros((size, size), dtype=int)
    return lattice

def compute_neighbor_indices(size):                                             # Calculates the neighbor indices
    neighbor_indices = {}
    for x in range(size):
        for y in range(size):
            neighbors = [
                ((x - 1) % size, y),
                ((x + 1) % size, y),
                (x, (y - 1) % size),
                (x, (y + 1) % size)
            ]
            neighbor_indices[(x, y)] = neighbors
    return neighbor_indices

def calculate_interaction_energy(lattice, site, particle, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH):            # Calculates the interaction energy
    x, y = site
    interaction_energy = 0
    for neighbor_coords in neighbor_indices[(x, y)]:
        neighbor_particle = lattice[neighbor_coords]
        if neighbor_particle != 0:
            if particle == 1:
                if neighbor_particle == 1:
                    interaction_energy += epsilon_NN
                else:
                    interaction_energy += epsilon_NH
            else:
                if neighbor_particle == 2:
                    interaction_energy += epsilon_HH
                else:
                    interaction_energy += epsilon_NH
    return interaction_energy

def get_adsorption_energy(particle_type, params):                               # Defines the adsorption energy at a site
    if particle_type == 1:                                                      # If N particle at site
        return params['epsilon_N']
    elif particle_type == 2:                                                    # If H particle at site
        return params['epsilon_H']
    return 0.0                                                                  # Zero adsorption energy at empty site

def attempt_move(lattice, N_N, N_H, N_empty, neighbor_indices, params):
    size = lattice.shape[0]
    N_sites = size * size
    beta = 1 / params['T']
    epsilon_N = params['epsilon_N']
    epsilon_H = params['epsilon_H']
    epsilon_NN = params['epsilon_NN']
    epsilon_HH = params['epsilon_HH']
    epsilon_NH = params['epsilon_NH']
    mu_N = params['mu_N']
    mu_H = params['mu_H']

    move_type_rand = np.random.rand()

    if move_type_rand < 1/3:                                                    # 1/3 probability to add N, H, or no particle
        if N_empty == 0:
            return N_N, N_H, N_empty                                            # No avialable empty sites

        empty_sites_coords = np.argwhere(lattice == 0)
        chosen_idx = np.random.randint(0, len(empty_sites_coords))
        site = tuple(empty_sites_coords[chosen_idx])

        if np.random.rand() < 0.5:                                              # 1/2 probability to add N or H particle
            particle = 1
            mu = mu_N
            epsilon_adsorption = epsilon_N
            N_s = N_N
        else:
            particle = 2
            mu = mu_H
            epsilon_adsorption = epsilon_H
            N_s = N_H

        interaction_energy = calculate_interaction_energy(lattice, site, particle, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH)
        delta_E = epsilon_adsorption + interaction_energy                       # Calculates sum of adsorption energy and interaction energy

        acc_prob = min(1.0, (N_empty) / (N_s + 1) * np.exp(-beta * (delta_E - mu)))    # Metropolis algorithm for acceptance criteria

        if np.random.rand() < acc_prob: 
            lattice[site] = particle
            if particle == 1:
                N_N += 1
            else:
                N_H += 1
            N_empty -= 1
    elif move_type_rand < 2/3:                                                  # 2/3 probability to remove N, H, or no particle
        if N_N + N_H == 0:
            return N_N, N_H, N_empty

        occupied_sites_coords = np.argwhere(lattice != 0)
        chosen_idx = np.random.randint(0, len(occupied_sites_coords))
        site = tuple(occupied_sites_coords[chosen_idx])

        particle = lattice[site]
        if particle == 1:
            mu = mu_N
            epsilon_adsorption = epsilon_N
            N_s = N_N
        else:
            mu = mu_H
            epsilon_adsorption = epsilon_H
            N_s = N_H

        interaction_energy = calculate_interaction_energy(lattice, site, particle, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH)
        delta_E = -(epsilon_adsorption + interaction_energy)                    # Change in energy from initial

        acc_prob = min(1.0, N_s / (N_empty + 1) * np.exp(-beta * (delta_E + mu)))

        if np.random.rand() < acc_prob:
            lattice[site] = 0
            if particle == 1:
                N_N -= 1
            else:
                N_H -= 1
            N_empty += 1
    else:
        if N_sites < 2:                                                         # Must have < 2 sites in order to swap 2 particles
            return N_N, N_H, N_empty

        site_indices = np.random.choice(N_sites, 2, replace=False)
        site1 = (site_indices[0] // size, site_indices[0] % size)
        site2 = (site_indices[1] // size, site_indices[1] % size)

        old_particle1 = lattice[site1]
        old_particle2 = lattice[site2]

        if old_particle1 == old_particle2:
            return N_N, N_H, N_empty                                            # Swaps particles at 2 sites

        interaction_energy1_before = calculate_interaction_energy(lattice, site1, old_particle1, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH)
        adsorption_energy1_before = get_adsorption_energy(old_particle1, params)
        interaction_energy2_before = calculate_interaction_energy(lattice, site2, old_particle2, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH)
        adsorption_energy2_before = get_adsorption_energy(old_particle2, params)
        E_before = (adsorption_energy1_before + interaction_energy1_before) + \
                   (adsorption_energy2_before + interaction_energy2_before)     # Calculates the energy before the swap

        temp_lattice = np.copy(lattice)                                         # Creates temporary lattice of old particle conditions
        temp_lattice[site1] = old_particle2
        temp_lattice[site2] = old_particle1

        interaction_energy1_after = calculate_interaction_energy(temp_lattice, site1, old_particle2, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH)
        adsorption_energy1_after = get_adsorption_energy(old_particle2, params)
        interaction_energy2_after = calculate_interaction_energy(temp_lattice, site2, old_particle1, neighbor_indices, epsilon_NN, epsilon_HH, epsilon_NH)
        adsorption_energy2_after = get_adsorption_energy(old_particle1, params)
        E_after = (adsorption_energy1_after + interaction_energy1_after) + \
                  (adsorption_energy2_after + interaction_energy2_after)        # Calculates the energy after the swap

        delta_E_swap = E_after - E_before

        acc_prob_swap = min(1.0, np.exp(-beta * delta_E_swap))

        if np.random.rand() < acc_prob_swap:
            lattice[site1] = old_particle2
            lattice[site2] = old_particle1

    return N_N, N_H, N_empty

def run_simulation(size, n_steps, params):
    lattice = initialize_lattice(size)
    neighbor_indices = compute_neighbor_indices(size)
    N_sites = size * size
    N_N = 0
    N_H = 0
    N_empty = N_sites
    coverage_N = np.zeros(n_steps)
    coverage_H = np.zeros(n_steps)

    for step in range(n_steps):
        N_N, N_H, N_empty = attempt_move(lattice, N_N, N_H, N_empty, neighbor_indices, params)
        coverage_N[step] = N_N / N_sites
        coverage_H[step] = N_H / N_sites

    return lattice, coverage_N, coverage_H

def plot_lattice(lattice, ax, title):
    size = lattice.shape[0]
    ax.set_xlim(0, size)
    ax.set_ylim(0, size)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_aspect('equal', adjustable='box')
    ax.set_title(title)

    for i in range(size + 1):                                                   # Creates a plot
        ax.plot([i, i], [0, size], color='lightgray', linewidth=0.5)
        ax.plot([0, size], [i, i], color='lightgray', linewidth=0.5)

    for x in range(size):                                                       # Creates markers for N (blue) and H (red) atoms
        for y in range(size):
            if lattice[x, y] == 1:
                ax.plot(x + 0.5, y + 0.5, 'o', color='blue', markersize=30)
                ax.text(x + 0.5, y + 0.5, 'N', ha='center', va='center', color='white', fontsize=12, fontweight='bold')
            elif lattice[x, y] == 2:
                ax.plot(x + 0.5, y + 0.5, 'o', color='red', markersize=30)
                ax.text(x + 0.5, y + 0.5, 'H', ha='center', va='center', color='white', fontsize=12, fontweight='bold')
    return ax


size = 4                                                                        # Reusing Ideal conditions
n_steps = 10000
mus_N = np.linspace(-0.2, 0, 7)
Ts = np.linspace(0.001, 0.019, 7)
params = []
for mu_N_val in mus_N:
    for T in Ts:
        params.append({
            'epsilon_N': -0.1,
            'epsilon_H': -0.1,
            'epsilon_NN': 0,
            'epsilon_HH': 0,
            'epsilon_NH': 0,
            'mu_N': mu_N_val,
            'mu_H': -0.1,
            'T': T                                                              # Temperature (in units of k)
        })

np.random.seed(42)

final_lattice = np.zeros((len(mus_N), len(Ts), size, size), dtype=int)
mean_coverage_N = np.zeros((len(mus_N), len(Ts)))
mean_coverage_H = np.zeros((len(mus_N), len(Ts)))

for i, param in enumerate(params):
    lattice, coverage_N, coverage_H = run_simulation(size, n_steps, param)

    mu_N_idx = i // len(Ts)
    T_idx = i % len(Ts)
    final_lattice[mu_N_idx, T_idx] = lattice
    mean_coverage_N[mu_N_idx, T_idx] = np.mean(coverage_N[-1000:])
    mean_coverage_H[mu_N_idx, T_idx] = np.mean(coverage_H[-1000:])

fig = plt.figure(figsize=(10, 8), layout='constrained')
gs = GridSpec(2, 3, figure=fig, height_ratios=[1, 1])

fig.text(0.5, 1.0, 'Ideal Mixture of N and H with Particle Swap - Phase Diagram', ha='center', va='bottom', fontsize=14)
fig.text(0.5, 0.44, 'Ideal Mixture of N and H with Particle Swap - Lattice', ha='center', va='bottom', fontsize=14)

ax_N_coverage = fig.add_subplot(gs[0, 0])
ax_H_coverage = fig.add_subplot(gs[0, 1])
ax_Total_coverage = fig.add_subplot(gs[0, 2])
ax_lattice_03 = fig.add_subplot(gs[1, 0])
ax_lattice_33 = fig.add_subplot(gs[1, 1])
ax_lattice_63 = fig.add_subplot(gs[1, 2])

# Subplot for mean coverage of N
ax_N_coverage.pcolormesh(mus_N, Ts, mean_coverage_N.T, cmap='viridis', vmin=0, vmax=1)
ax_N_coverage.set_title(r'$\langle \theta_N \rangle$')
ax_N_coverage.set_xlabel(r'$\mu_N$')
ax_N_coverage.set_ylabel(r'$T$')

# Subplot for mean coverage of H
ax_H_coverage.pcolormesh(mus_N, Ts, mean_coverage_H.T, cmap='viridis', vmin=0, vmax=1)
ax_H_coverage.set_title(r'$\langle \theta_H \rangle$')
ax_H_coverage.set_xlabel(r'$\mu_N$')
ax_H_coverage.set_yticks([])

# Subplot for mean total coverage
cax = ax_Total_coverage.pcolormesh(mus_N, Ts, mean_coverage_N.T + mean_coverage_H.T, cmap='viridis', vmin=0, vmax=1)
ax_Total_coverage.set_title(r'$\langle \theta_N + \theta_H \rangle$')
ax_Total_coverage.set_xlabel(r'$\mu_N$')
ax_Total_coverage.set_yticks([])
fig.colorbar(cax, ax=ax_Total_coverage, location='right', fraction=0.1, pad=0.04)

plot_lattice(final_lattice[0, 3], ax_lattice_03, r'$\mu_N = -0.2$ eV, $T = 0.01 / k$')
plot_lattice(final_lattice[3, 3], ax_lattice_33, r'$\mu_N = -0.1$ eV, $T = 0.01 / k$')
plot_lattice(final_lattice[6, 3], ax_lattice_63, r'$\mu_N = 0$ eV, $T = 0.01 / k$')

plt.show()
