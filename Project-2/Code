import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

k_B = 1.0                                                               # Boltzmann's constant

def apply_pbc(position, box_size):                                      # Defines periodic boundary conditions
    return np.mod(position, box_size)

def minimum_image(displacement, box_size):
    return displacement - box_size * np.round(displacement / box_size)

def initialize_chain(n_particles, box_size, r0):                        # Initializes chain function
    positions = np.zeros((n_particles, 3))
    current_position = np.array([box_size / 2, box_size / 2, box_size / 2])
    positions[0] = current_position
    for i in range(1, n_particles):
        direction = np.random.rand(3) - 0.5
        direction = direction / np.linalg.norm(direction)
        next_position = current_position + r0 * direction
        positions[i] = apply_pbc(next_position, box_size)
        current_position = positions[i]
    return positions

def initialize_velocities(n_particles, target_temperature, mass):       # Initializes velocity function
    scale = np.sqrt(k_B * target_temperature / mass)
    velocities = np.random.normal(scale=scale, size=(n_particles, 3))
    velocities -= np.mean(velocities, axis=0)
    return velocities

def compute_harmonic_forces(positions, k, r0, box_size):                # Harmonic forces function
    n_particles = positions.shape[0]
    forces = np.zeros_like(positions)
    for i in range(n_particles - 1):
        displacement = positions[i+1] - positions[i]
        displacement = minimum_image(displacement, box_size)
        distance = np.linalg.norm(displacement)
        if distance == 0:
            continue
        force_magnitude = -k * (distance - r0)
        force = force_magnitude * (displacement / distance)
        forces[i] -= force
        forces[i+1] += force
    return forces

def compute_lennard_jones_forces(positions, epsilon_repulsive, epsilon_attractive, sigma, box_size, lj_cutoff):    # Lennard_Jones forces function
    n_particles = positions.shape[0]
    forces = np.zeros_like(positions)
    lj_cutoff_repulsive_wca = (2**(1/6)) * sigma

    for i in range(n_particles):
        for j in range(i + 1, n_particles):
            if abs(i - j) == 1:
                continue

            displacement = positions[j] - positions[i]
            displacement = minimum_image(displacement, box_size)
            distance = np.linalg.norm(displacement)

            if distance == 0:
                continue

            if distance < lj_cutoff:                                                         # Lennard_Jones cutoff distance
                r_inv = 1.0 / distance
                r6 = (sigma * r_inv)**6
                r12 = r6**2

                force_magnitude = 0.0
                if abs(i - j) == 2:
                    if distance < lj_cutoff_repulsive_wca:
                        force_magnitude = 24 * epsilon_repulsive * (2 * r12 - r6) * r_inv
                elif abs(i - j) > 2:
                    force_magnitude = 24 * epsilon_attractive * (2 * r12 - r6) * r_inv

                if force_magnitude != 0.0:
                    force = force_magnitude * (displacement / distance)
                    forces[i] -= force
                    forces[j] += force
    return forces

def compute_total_forces(positions, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff):                           # Compute total forces function
    forces_harmonic = compute_harmonic_forces(positions, k, r0, box_size)
    forces_lj = compute_lennard_jones_forces(positions, epsilon_repulsive, epsilon_attractive, sigma, box_size, lj_cutoff)
    return forces_harmonic + forces_lj

def velocity_verlet(positions, velocities, forces, dt, mass, box_size, k, r0, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff):  # velocity_verlet function
    velocities_half = velocities + 0.5 * forces / mass * dt
    positions_new = positions + velocities_half * dt
    positions_new = apply_pbc(positions_new, box_size)

    forces_new = compute_total_forces(positions_new, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff)

    velocities_new = velocities_half + 0.5 * forces_new / mass * dt
    return positions_new, velocities_new, forces_new

def rescale_velocities(velocities, target_temperature, mass, n_particles):               # Rescale velocities function
    kinetic_energy = 0.5 * mass * np.sum(np.linalg.norm(velocities, axis=1)**2)
    current_temperature = (2 / (3 * n_particles)) * kinetic_energy / k_B
    if current_temperature == 0:
        return velocities
    scaling_factor = np.sqrt(target_temperature / current_temperature)
    velocities_scaled = velocities * scaling_factor
    return velocities_scaled

def calculate_harmonic_potential_total(positions, k, r0, box_size):                     # Harmonic potential calculation function
    n_particles = positions.shape[0]
    total_U = 0.0
    for i in range(n_particles - 1):
        displacement = positions[i+1] - positions[i]
        displacement = minimum_image(displacement, box_size)
        distance = np.linalg.norm(displacement)
        total_U += 0.5 * k * (distance - r0)**2
    return total_U

def calculate_lj_potential_total(positions, epsilon_repulsive, epsilon_attractive, sigma, box_size, lj_cutoff_repulsive, lj_cutoff_attractive):
    n_particles = positions.shape[0]
    total_U = 0.0
    for i in range(n_particles):
        for j in range(i + 1, n_particles):
            if abs(i - j) == 1:
                continue

            displacement = positions[j] - positions[i]
            displacement = minimum_image(displacement, box_size)
            distance = np.linalg.norm(displacement)

            if distance == 0:
                continue

            r_inv = 1.0 / distance
            r6 = (sigma * r_inv)**6
            r12 = r6**2

            if abs(i - j) == 2:
                if distance < lj_cutoff_repulsive:
                    total_U += 4 * epsilon_repulsive * (r12 - r6) + epsilon_repulsive
            elif abs(i - j) > 2:
                if distance < lj_cutoff_attractive:
                    total_U += 4 * epsilon_attractive * (r12 - r6)
    return total_U

Rg_values = []                   # Creates list radius of gyration
Ree_values = []                  # Creates list for end-to-end distance
potential_energies_avg = []      # Creates list for average potential energies

def calculate_total_potential_energy(positions, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff_repulsive, lj_cutoff_attractive):
    U_harmonic = calculate_harmonic_potential_total(positions, k, r0, box_size)
    U_lj = calculate_lj_potential_total(positions, epsilon_repulsive, epsilon_attractive, sigma, box_size, lj_cutoff_repulsive, lj_cutoff_attractive)
    return U_harmonic + U_lj

def calculate_radius_of_gyration(positions):                               # Radius of gyration function
    center_of_mass = np.mean(positions, axis=0)
    Rg_squared = np.mean(np.sum((positions - center_of_mass)**2, axis=1))
    Rg = np.sqrt(Rg_squared)
    return Rg

def calculate_end_to_end_distance(positions):                              # End-to-end distance function
    Ree = np.linalg.norm(positions[-1] - positions[0])
    return Ree

dt = 0.01                                                                  # Time step
total_simulation_steps = 10000                                             # Total number of simulation steps for each temperature run
equilibration_steps = 2000                                                 # Number of steps for equilibration before data collection
box_size = 100.0                                                           # Size of the cubic box
k = 1.0                                                                    # Spring constant
mass = 1.0                                                                 # Particle mass
r0 = 1.0                                                                   # Equilibrium bond length
n_particles = 20                                                           # Number of particles (ensured to be 20)
sigma = 1.0                                                                # LJ potential parameter

lj_force_cutoff = 2.5 * sigma
lj_potential_cutoff_repulsive = (2**(1/6)) * sigma
lj_potential_cutoff_attractive = 2.5 * sigma

rescale_interval = 100                                                     # Steps between velocity rescaling
temperatures = np.linspace(0.1, 1.0, 10)                                   # Array of temperatures

minimization_step_size = 0.001
minimization_tolerance = 0.1
minimization_max_iterations = 50000

original_epsilon_repulsive = 1.0
original_epsilon_attractive = 0.5

for T in temperatures:
    target_temperature = T

    positions = initialize_chain(n_particles, box_size, r0)
    velocities = initialize_velocities(n_particles, target_temperature, mass)

    forces = compute_total_forces(positions, k, r0, box_size, original_epsilon_repulsive, original_epsilon_attractive, sigma, lj_force_cutoff)

    potential_energy_per_step = []

    for step in range(total_simulation_steps):
        positions, velocities, forces = velocity_verlet(
            positions, velocities, forces, dt, mass, box_size,
            k, r0, original_epsilon_repulsive, original_epsilon_attractive, sigma, lj_force_cutoff
        )

        if step % rescale_interval == 0:
            velocities = rescale_velocities(velocities, target_temperature, mass, n_particles)

        if step >= equilibration_steps:
            current_potential_energy = calculate_total_potential_energy(
                positions, k, r0, box_size, original_epsilon_repulsive, original_epsilon_attractive, sigma,
                lj_potential_cutoff_repulsive, lj_potential_cutoff_attractive
            )
            potential_energy_per_step.append(current_potential_energy)

    Rg = calculate_radius_of_gyration(positions)
    Ree = calculate_end_to_end_distance(positions)

    Rg_values.append(Rg)
    Ree_values.append(Ree)
    potential_energies_avg.append(np.mean(potential_energy_per_step))

plt.figure(figsize=(8, 6))
plt.plot(temperatures, Rg_values, marker='o', linestyle='-', color='blue', label='Radius of Gyration (Rg)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('Radius of Gyration (Rg)')
plt.title('Radius of Gyration vs Temperature (Original)')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(8, 6))
plt.plot(temperatures, Ree_values, marker='o', linestyle='-', color='green', label='End-to-End Distance (Ree)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('End-to-End Distance (Ree)')
plt.title('End-to-End Distance vs Temperature (Original)')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(8, 6))
plt.plot(temperatures, potential_energies_avg, marker='o', linestyle='-', color='red', label='Average Potential Energy (Original)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('Average Potential Energy (Reduced Units)')
plt.title('Average Potential Energy vs Temperature (Original)')
plt.legend()
plt.grid(True)
plt.show()

def steepest_descent_minimization(positions, compute_forces_func, step_size, tolerance, box_size,
                                  k, r0, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff,
                                  max_iterations=10000):

    for iteration in range(max_iterations):
        forces = compute_forces_func(positions, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff)

        total_force_magnitude = np.linalg.norm(forces)

        if total_force_magnitude < tolerance:
            print(f"Energy minimization converged in {iteration + 1} iterations. Total force magnitude: {total_force_magnitude:.4f}")
            break

        positions -= step_size * forces

        positions = apply_pbc(positions, box_size)

    return positions

current_epsilon_repulsive = original_epsilon_repulsive
current_epsilon_attractive = original_epsilon_attractive

initial_positions_for_minimization = initialize_chain(n_particles, box_size, r0)

minimized_positions = steepest_descent_minimization(
    positions=initial_positions_for_minimization,
    compute_forces_func=compute_total_forces,
    step_size=minimization_step_size,
    tolerance=minimization_tolerance,
    box_size=box_size,
    k=k,
    r0=r0,
    epsilon_repulsive=current_epsilon_repulsive,
    epsilon_attractive=current_epsilon_attractive,
    sigma=sigma,
    lj_cutoff=lj_force_cutoff,
    max_iterations=minimization_max_iterations
)

fig = plt.figure(figsize=(12, 6))

ax1 = fig.add_subplot(121, projection='3d')
ax1.scatter(initial_positions_for_minimization[:, 0], initial_positions_for_minimization[:, 1], initial_positions_for_minimization[:, 2],
           color='red', s=50, label='Initial Beads')
for i in range(n_particles - 1):
    ax1.plot(initial_positions_for_minimization[i:i+2, 0], initial_positions_for_minimization[i:i+2, 1], initial_positions_for_minimization[i:i+2, 2],
             color='gray', linestyle='-', linewidth=1)
ax1.set_title('Initial Polymer Configuration')
ax1.set_xlabel('X')
ax1.set_ylabel('Y')
ax1.set_zlabel('Z')
ax1.view_init(elev=20, azim=-60)

ax2 = fig.add_subplot(122, projection='3d')
ax2.scatter(minimized_positions[:, 0], minimized_positions[:, 1], minimized_positions[:, 2],
           color='blue', s=50, label='Minimized Beads')
for i in range(n_particles - 1):
    ax2.plot(minimized_positions[i:i+2, 0], minimized_positions[i:i+2, 1], minimized_positions[i:i+2, 2],
             color='lightblue', linestyle='-', linewidth=1)
ax2.set_title('Minimized Polymer Configuration (Steepest Descent)')
ax2.set_xlabel('X')
ax2.set_ylabel('Y')
ax2.set_zlabel('Z')
ax2.view_init(elev=20, azim=-60)

plt.tight_layout()
plt.show()


optimized_k = 1.5
optimized_epsilon_repulsive = 3.0
optimized_epsilon_attractive = 0.5

Rg_values_optimized = []
Ree_values_optimized = []
potential_energies_avg_optimized = []

positions_low_temp_optimized = None
positions_high_temp_optimized = None

print("\nStarting simulation with Optimized parameters (k=1.5, epsilon_repulsive=3.0, epsilon_attractive=0.5)...")
for T in temperatures:
    target_temperature = T

    initial_positions_for_minimization = initialize_chain(n_particles, box_size, r0)

    minimized_positions = steepest_descent_minimization(
        positions=initial_positions_for_minimization,
        compute_forces_func=compute_total_forces,
        step_size=minimization_step_size,
        tolerance=minimization_tolerance,
        box_size=box_size,
        k=optimized_k,
        r0=r0,
        epsilon_repulsive=optimized_epsilon_repulsive,
        epsilon_attractive=optimized_epsilon_attractive,
        sigma=sigma,
        lj_cutoff=lj_force_cutoff,
        max_iterations=minimization_max_iterations
    )

    positions = minimized_positions

    velocities = initialize_velocities(n_particles, target_temperature, mass)

    forces = compute_total_forces(positions, optimized_k, r0, box_size, optimized_epsilon_repulsive, optimized_epsilon_attractive, sigma, lj_force_cutoff)

    potential_energy_per_step = []

    for step in range(total_simulation_steps):
        positions, velocities, forces = velocity_verlet(
            positions, velocities, forces, dt, mass, box_size,
            optimized_k, r0, optimized_epsilon_repulsive, optimized_epsilon_attractive, sigma, lj_force_cutoff
        )

        if step % rescale_interval == 0:
            velocities = rescale_velocities(velocities, target_temperature, mass, n_particles)

        if step >= equilibration_steps:
            current_potential_energy = calculate_total_potential_energy(
                positions, optimized_k, r0, box_size, optimized_epsilon_repulsive, optimized_epsilon_attractive, sigma,
                lj_potential_cutoff_repulsive, lj_potential_cutoff_attractive
            )
            potential_energy_per_step.append(current_potential_energy)

    Rg = calculate_radius_of_gyration(positions)
    Ree = calculate_end_to_end_distance(positions)

    Rg_values_optimized.append(Rg)
    Ree_values_optimized.append(Ree)
    potential_energies_avg_optimized.append(np.mean(potential_energy_per_step))

    if T == temperatures[0]:
        positions_low_temp_optimized = np.copy(positions)
    if T == temperatures[-1]:
        positions_high_temp_optimized = np.copy(positions)

plt.figure(figsize=(8, 6))
plt.plot(temperatures, Rg_values_optimized, marker='o', linestyle='-', color='blue', label='Rg (Optimized Params)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('Radius of Gyration (Rg)')
plt.title('Radius of Gyration vs Temperature (Optimized Parameters)')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(8, 6))
plt.plot(temperatures, Ree_values_optimized, marker='o', linestyle='-', color='green', label='Ree (Optimized Params)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('End-to-End Distance (Ree)')
plt.title('End-to-End Distance vs Temperature (Optimized Parameters)')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(8, 6))
plt.plot(temperatures, potential_energies_avg_optimized, marker='o', linestyle='-', color='red', label='Average Potential Energy (Optimized Params)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('Average Potential Energy (Reduced Units)')
plt.title('Average Potential Energy vs Temperature (Optimized Parameters)')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 7))
plt.plot(temperatures, Rg_values, marker='o', linestyle='-', color='blue', label='Rg (Original Parameters)')
plt.plot(temperatures, Rg_values_optimized, marker='s', linestyle=':', color='purple', label='Rg (Optimized Parameters)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('Radius of Gyration (Rg)')
plt.title('Radius of Gyration vs Temperature: Original vs. Optimized Parameters')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 7))
plt.plot(temperatures, Ree_values, marker='o', linestyle='-', color='blue', label='Ree (Original Parameters)')
plt.plot(temperatures, Ree_values_optimized, marker='s', linestyle=':', color='purple', label='Ree (Optimized Parameters)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('End-to-End Distance (Ree)')
plt.title('End-to-End Distance vs Temperature: Original vs. Optimized Parameters')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 7))
plt.plot(temperatures, potential_energies_avg, marker='o', linestyle='-', color='blue', label='Avg Potential Energy (Original Parameters)')
plt.plot(temperatures, potential_energies_avg_optimized, marker='s', linestyle=':', color='purple', label='Avg Potential Energy (Optimized Parameters)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('Average Potential Energy (Reduced Units)')
plt.title('Average Potential Energy vs Temperature: Original vs. Optimized Parameters')
plt.legend()
plt.grid(True)
plt.show()

fig = plt.figure(figsize=(12, 6))

ax1 = fig.add_subplot(121, projection='3d')
ax1.scatter(positions_low_temp_optimized[:, 0], positions_low_temp_optimized[:, 1], positions_low_temp_optimized[:, 2],
           color='red', s=50, label='Beads at Lowest Temp (Optimized)')
for i in range(n_particles - 1):
    ax1.plot(positions_low_temp_optimized[i:i+2, 0], positions_low_temp_optimized[i:i+2, 1], positions_low_temp_optimized[i:i+2, 2],
             color='gray', linestyle='-', linewidth=1)
ax1.set_title('Polymer Configuration at Lowest Temperature (Optimized Parameters)')
ax1.set_xlabel('X')
ax1.set_ylabel('Y')
ax1.set_zlabel('Z')
ax1.view_init(elev=20, azim=-60)

ax2 = fig.add_subplot(122, projection='3d')
ax2.scatter(positions_high_temp_optimized[:, 0], positions_high_temp_optimized[:, 1], positions_high_temp_optimized[:, 2],
           color='blue', s=50, label='Beads at Highest Temp (Optimized)')
for i in range(n_particles - 1):
    ax2.plot(positions_high_temp_optimized[i:i+2, 0], positions_high_temp_optimized[i:i+2, 1], positions_high_temp_optimized[i:i+2, 2],
             color='lightblue', linestyle='-', linewidth=1)
ax2.set_title('Polymer Configuration at Highest Temperature (Optimized Parameters)')
ax2.set_xlabel('X')
ax2.set_ylabel('Y')
ax2.set_zlabel('Z')
ax2.view_init(elev=20, azim=-60)

plt.tight_layout()
plt.show()
