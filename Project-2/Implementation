import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

k_B = 1.0                                                               # Boltzmann's constant

def apply_pbc(position, box_size):                                      # Defines periodic boundary conditions           
    return np.mod(position, box_size)

def minimum_image(displacement, box_size):                              # Minimum image function
    return displacement - box_size * np.round(displacement / box_size)

def initialize_chain(n_particles, box_size, r0):                        # Initializes chain function
    positions = np.zeros((n_particles, 3))
    current_position = np.array([box_size / 2, box_size / 2, box_size / 2])
    positions[0] = current_position
    for i in range(1, n_particles):
        direction = np.random.rand(3) - 0.5
        direction = direction / np.linalg.norm(direction)
        next_position = current_position + r0 * direction
        positions[i] = apply_pbc(next_position, box_size)
        current_position = positions[i]
    return positions

def initialize_velocities(n_particles, target_temperature, mass):       # Initializes velocity function
    scale = np.sqrt(k_B * target_temperature / mass)
    velocities = np.random.normal(scale=scale, size=(n_particles, 3))
    velocities -= np.mean(velocities, axis=0)
    return velocities

def compute_harmonic_forces(positions, k, r0, box_size):                # Harmonic forces function
    n_particles = positions.shape[0]
    forces = np.zeros_like(positions)
    for i in range(n_particles - 1):
        displacement = positions[i+1] - positions[i]
        displacement = minimum_image(displacement, box_size)
        distance = np.linalg.norm(displacement)
        if distance == 0:
            continue
        force_magnitude = -k * (distance - r0)
        force = force_magnitude * (displacement / distance)
        forces[i] -= force
        forces[i+1] += force
    return forces

def compute_lennard_jones_forces(positions, epsilon_repulsive, epsilon_attractive, sigma, box_size, lj_cutoff):    # Lennard_Jones forces function
    n_particles = positions.shape[0]
    forces = np.zeros_like(positions)
    lj_cutoff_repulsive_wca = (2**(1/6)) * sigm

    for i in range(n_particles):
        for j in range(i + 1, n_particles):
            if abs(i - j) == 1:
                continue

            displacement = positions[j] - positions[i]
            displacement = minimum_image(displacement, box_size)
            distance = np.linalg.norm(displacement)

            if distance == 0:
                continue # Avoid division by zero

            if distance < lj_cutoff:                                                         # Lennard_Jones cutoff distance
                r_inv = 1.0 / distance
                r6 = (sigma * r_inv)**6
                r12 = r6**2

                force_magnitude = 0.0
                if abs(i - j) == 2:
                    if distance < lj_cutoff_repulsive_wca:
                        force_magnitude = 24 * epsilon_repulsive * (2 * r12 - r6) * r_inv
                elif abs(i - j) > 2:
                    force_magnitude = 24 * epsilon_attractive * (2 * r12 - r6) * r_inv

                if force_magnitude != 0.0:
                    force = force_magnitude * (displacement / distance)
                    forces[i] -= force
                    forces[j] += force
    return forces

def compute_total_forces(positions, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff):                           # Compute total forces function
    forces_harmonic = compute_harmonic_forces(positions, k, r0, box_size)
    forces_lj = compute_lennard_jones_forces(positions, epsilon_repulsive, epsilon_attractive, sigma, box_size, lj_cutoff)
    return forces_harmonic + forces_lj

def velocity_verlet(positions, velocities, forces, dt, mass, box_size, k, r0, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff):  # velocity_verlet function
    velocities_half = velocities + 0.5 * forces / mass * dt
    positions_new = positions + velocities_half * dt
    positions_new = apply_pbc(positions_new, box_size)

    forces_new = compute_total_forces(positions_new, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff)

    velocities_new = velocities_half + 0.5 * forces_new / mass * dt
    return positions_new, velocities_new, forces_new

def rescale_velocities(velocities, target_temperature, mass, n_particles):               # Rescale velocities function
    kinetic_energy = 0.5 * mass * np.sum(np.linalg.norm(velocities, axis=1)**2)
    current_temperature = (2 / (3 * n_particles)) * kinetic_energy / k_B
    if current_temperature == 0:
        return velocities
    scaling_factor = np.sqrt(target_temperature / current_temperature)
    velocities_scaled = velocities * scaling_factor
    return velocities_scaled

def calculate_harmonic_potential_total(positions, k, r0, box_size):                     # Harmonic potential calculation function
    n_particles = positions.shape[0]
    total_U = 0.0
    for i in range(n_particles - 1):
        displacement = positions[i+1] - positions[i]
        displacement = minimum_image(displacement, box_size)
        distance = np.linalg.norm(displacement)
        total_U += 0.5 * k * (distance - r0)**2
    return total_U

def calculate_lj_potential_total(positions, epsilon_repulsive, epsilon_attractive, sigma, box_size, lj_cutoff_repulsive, lj_cutoff_attractive):
    n_particles = positions.shape[0]
    total_U = 0.0
    for i in range(n_particles):
        for j in range(i + 1, n_particles):
            if abs(i - j) == 1:
                continue

            displacement = positions[j] - positions[i]
            displacement = minimum_image(displacement, box_size)
            distance = np.linalg.norm(displacement)

            if distance == 0:
                continue

            r_inv = 1.0 / distance
            r6 = (sigma * r_inv)**6
            r12 = r6**2

            if abs(i - j) == 2:
                if distance < lj_cutoff_repulsive:
                    total_U += 4 * epsilon_repulsive * (r12 - r6) + epsilon_repulsive
            elif abs(i - j) > 2:
                if distance < lj_cutoff_attractive:
                    total_U += 4 * epsilon_attractive * (r12 - r6)
    return total_U

Rg_values = []                   # Creates list radius of gyration
Ree_values = []                  # Creates list for end-to-end distance
potential_energies_avg = []      # Creates list for average potential energies

def calculate_total_potential_energy(positions, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff_repulsive, lj_cutoff_attractive):
    U_harmonic = calculate_harmonic_potential_total(positions, k, r0, box_size)
    U_lj = calculate_lj_potential_total(positions, epsilon_repulsive, epsilon_attractive, sigma, box_size, lj_cutoff_repulsive, lj_cutoff_attractive)
    return U_harmonic + U_lj

def calculate_radius_of_gyration(positions):                               # Radius of gyration function
    center_of_mass = np.mean(positions, axis=0)
    Rg_squared = np.mean(np.sum((positions - center_of_mass)**2, axis=1))
    Rg = np.sqrt(Rg_squared)
    return Rg

def calculate_end_to_end_distance(positions):                              # End-to-end distance function
    Ree = np.linalg.norm(positions[-1] - positions[0])
    return Ree

dt = 0.01                                                                  # Time step
total_simulation_steps = 10000                                             # Total number of simulation steps for each temperature run
equilibration_steps = 2000                                                 # Number of steps for equilibration before data collection
box_size = 100.0                                                           # Size of the cubic box
k = 1.0                                                                    # Spring constant
mass = 1.0                                                                 # Particle mass
r0 = 1.0                                                                   # Equilibrium bond length
n_particles = 20                                                           # Number of particles
epsilon_repulsive = 1.0                                                    # Depth of repulsive LJ potential
epsilon_attractive = 0.5                                                   # Depth of attractive LJ potential
sigma = 1.0                                                                # LJ potential parameter

lj_force_cutoff = 2.5 * sigma                                              # Cutoff distance for Lennard-Jones forces
lj_potential_cutoff_repulsive = (2**(1/6)) * sigma
lj_potential_cutoff_attractive = 2.5 * sigma

rescale_interval = 100                                                     # Steps between velocity rescaling
temperatures = np.linspace(0.1, 1.0, 10)                                   # Array of temperatures

for T in temperatures:
    target_temperature = T

    positions = initialize_chain(n_particles, box_size, r0)                     # Initalize position at each temperature
    velocities = initialize_velocities(n_particles, target_temperature, mass)   # Initalize velocity at each temperature

    forces = compute_total_forces(positions, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma, lj_force_cutoff)

    potential_energy_per_step = []                                             # Creates list to store potential energy per step

    for step in range(total_simulation_steps):                                 # Implementing below functions at each temperature
        positions, velocities, forces = velocity_verlet(
            positions, velocities, forces, dt, mass, box_size,
            k, r0, epsilon_repulsive, epsilon_attractive, sigma, lj_force_cutoff
        )

        if step % rescale_interval == 0:
            velocities = rescale_velocities(velocities, target_temperature, mass, n_particles)    # Rescaling velocities with a thermostat

        if step >= equilibration_steps:
            current_potential_energy = calculate_total_potential_energy(
                positions, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma,
                lj_potential_cutoff_repulsive, lj_potential_cutoff_attractive
            )
            potential_energy_per_step.append(current_potential_energy)                          # Update potential energy after equilibration

    Rg = calculate_radius_of_gyration(positions)
    Ree = calculate_end_to_end_distance(positions)

    Rg_values.append(Rg)
    Ree_values.append(Ree)
    potential_energies_avg.append(np.mean(potential_energy_per_step))

plt.figure(figsize=(8, 6))
plt.plot(temperatures, Rg_values, marker='o', linestyle='-', color='blue', label='Radius of Gyration (Rg)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('Radius of Gyration (Rg)')
plt.title('Radius of Gyration vs Temperature')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(8, 6))
plt.plot(temperatures, Ree_values, marker='o', linestyle='-', color='green', label='End-to-End Distance (Ree)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('End-to-End Distance (Ree)')
plt.title('End-to-End Distance vs Temperature')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(8, 6))
plt.plot(temperatures, potential_energies_avg, marker='o', linestyle='-', color='red', label='Average Potential Energy')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('Average Potential Energy (Reduced Units)')
plt.title('Average Potential Energy vs Temperature')
plt.legend()
plt.grid(True)
plt.show()

def steepest_descent_minimization(positions, compute_forces_func, step_size, tolerance, box_size,           # Steepest descent minimization function
                                  k, r0, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff,
                                  max_iterations=10000):

    for iteration in range(max_iterations):
        forces = compute_forces_func(positions, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff)

        total_force_magnitude = np.linalg.norm(forces)                                                      # Sum of the magnitudes of all forces

        if total_force_magnitude < tolerance:
            print(f"Energy minimization converged in {iteration + 1} iterations. Total force magnitude: {total_force_magnitude:.4f}")
            break

        positions -= step_size * forces                                                                    # Update positions opposite to forces

        positions = apply_pbc(positions, box_size)                                                         # Apply periodic boundary conditions

    else:
        print(f"Energy minimization did not converge after {max_iterations} iterations. Final force magnitude: {total_force_magnitude:.4f}")

    return positions

# Define minimization parameters
minimization_step_size = 0.001  # Step size for steepest descent
minimization_tolerance = 0.1    # Convergence criterion for total force magnitude
minimization_max_iterations = 50000 # Increased max_iterations for potentially slower convergence

# Initialize a chain
initial_positions_for_minimization = initialize_chain(n_particles, box_size, r0)

# Perform energy minimization
minimized_positions = steepest_descent_minimization(
    positions=initial_positions_for_minimization,
    compute_forces_func=compute_total_forces,
    step_size=minimization_step_size,
    tolerance=minimization_tolerance,
    box_size=box_size,
    k=k,
    r0=r0,
    epsilon_repulsive=epsilon_repulsive,
    epsilon_attractive=epsilon_attractive,
    sigma=sigma,
    lj_cutoff=lj_force_cutoff,
    max_iterations=minimization_max_iterations
)


# Create a new figure and a 3D subplot
fig = plt.figure(figsize=(12, 6))

# Plot initial configuration
ax1 = fig.add_subplot(121, projection='3d')
ax1.scatter(initial_positions_for_minimization[:, 0], initial_positions_for_minimization[:, 1], initial_positions_for_minimization[:, 2],
           color='red', s=50, label='Initial Beads')
for i in range(n_particles - 1):
    ax1.plot(initial_positions_for_minimization[i:i+2, 0], initial_positions_for_minimization[i:i+2, 1], initial_positions_for_minimization[i:i+2, 2],
             color='gray', linestyle='-', linewidth=1)
ax1.set_title('Initial Polymer Configuration')
ax1.set_xlabel('X')
ax1.set_ylabel('Y')
ax1.set_zlabel('Z')
ax1.view_init(elev=20, azim=-60)

# Plot minimized configuration
ax2 = fig.add_subplot(122, projection='3d')
ax2.scatter(minimized_positions[:, 0], minimized_positions[:, 1], minimized_positions[:, 2],
           color='blue', s=50, label='Minimized Beads')
for i in range(n_particles - 1):
    ax2.plot(minimized_positions[i:i+2, 0], minimized_positions[i:i+2, 1], minimized_positions[i:i+2, 2],
             color='lightblue', linestyle='-', linewidth=1)
ax2.set_title('Minimized Polymer Configuration (Steepest Descent)')
ax2.set_xlabel('X')
ax2.set_ylabel('Y')
ax2.set_zlabel('Z')
ax2.view_init(elev=20, azim=-60)

plt.tight_layout()
plt.show()


# --- MODIFIED PARAMETERS FOR THIS RUN ---
epsilon_repulsive = 2.0  # Increased depth of repulsive LJ potential (was 1.0)
epsilon_attractive = 0.1 # Decreased depth of attractive LJ potential (was 0.5)
# ----------------------------------------

sigma = 1.0  # LJ potential parameter

# Lennard-Jones cutoff distances
lj_force_cutoff = 2.5 * sigma  # Cutoff distance for Lennard-Jones forces
lj_potential_cutoff_repulsive = (2**(1/6)) * sigma  # Cutoff for repulsive 1-3 LJ potential energy (WCA)
lj_potential_cutoff_attractive = 2.5 * sigma # Cutoff for attractive non-bonded LJ potential energy

rescale_interval = 100                                     # Steps between velocity rescaling
temperatures = np.linspace(0.1, 1.0, 10)

minimization_step_size = 0.001                             # Step size for steepest descent
minimization_tolerance = 0.1                               # Convergence criterion for total force magnitude
minimization_max_iterations = 50000                        # Increased max_iterations for potentially slower convergence

Rg_values_adjusted = []
Ree_values_adjusted = []
potential_energies_avg_adjusted = []

positions_low_temp_adjusted = None
positions_high_temp_adjusted = None

for T in temperatures:
    target_temperature = T

    initial_positions_for_minimization = initialize_chain(n_particles, box_size, r0)             # Creates an initial chain for minimization

    minimized_positions = steepest_descent_minimization(
        positions=initial_positions_for_minimization,
        compute_forces_func=compute_total_forces,
        step_size=minimization_step_size,
        tolerance=minimization_tolerance,
        box_size=box_size,
        k=k,
        r0=r0,
        epsilon_repulsive=epsilon_repulsive,
        epsilon_attractive=epsilon_attractive,
        sigma=sigma,
        lj_cutoff=lj_force_cutoff,
        max_iterations=minimization_max_iterations
    )

    positions = minimized_positions

    velocities = initialize_velocities(n_particles, target_temperature, mass)

    forces = compute_total_forces(positions, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma, lj_force_cutoff)

    potential_energy_per_step = []

    for step in range(total_simulation_steps):
        positions, velocities, forces = velocity_verlet(
            positions, velocities, forces, dt, mass, box_size,
            k, r0, epsilon_repulsive, epsilon_attractive, sigma, lj_force_cutoff
        )

        if step % rescale_interval == 0:
            velocities = rescale_velocities(velocities, target_temperature, mass, n_particles)

        if step >= equilibration_steps:
            current_potential_energy = calculate_total_potential_energy(
                positions, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma,
                lj_potential_cutoff_repulsive, lj_potential_cutoff_attractive
            )
            potential_energy_per_step.append(current_potential_energy)

    Rg = calculate_radius_of_gyration(positions)
    Ree = calculate_end_to_end_distance(positions)

    Rg_values_adjusted.append(Rg)
    Ree_values_adjusted.append(Ree)
    potential_energies_avg_adjusted.append(np.mean(potential_energy_per_step))

    if T == temperatures[0]:
        positions_low_temp_adjusted = np.copy(positions)        # Stores position at lowest temperature
    if T == temperatures[-1]:
        positions_high_temp_adjusted = np.copy(positions)       # Stores position at highest temperature

plt.figure(figsize=(8, 6))
plt.plot(temperatures, Rg_values_adjusted, marker='o', linestyle='-', color='blue', label='Rg (Adjusted Params)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('Radius of Gyration (Rg)')
plt.title('Radius of Gyration vs Temperature (Adjusted Parameters)')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(8, 6))
plt.plot(temperatures, Ree_values_adjusted, marker='o', linestyle='-', color='green', label='Ree (Adjusted Params)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('End-to-End Distance (Ree)')
plt.title('End-to-End Distance vs Temperature (Adjusted Parameters)')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(8, 6))
plt.plot(temperatures, potential_energies_avg_adjusted, marker='o', linestyle='-', color='red', label='Average Potential Energy (Adjusted Params)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('Average Potential Energy (Reduced Units)')
plt.title('Average Potential Energy vs Temperature (Adjusted Parameters)')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 7))
plt.plot(temperatures, Rg_values, marker='o', linestyle='-', color='blue', label='Rg (Original Parameters)')
plt.plot(temperatures, Rg_values_adjusted, marker='x', linestyle='--', color='red', label='Rg (Adjusted Parameters)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('Radius of Gyration (Rg)')
plt.title('Radius of Gyration vs Temperature: Original vs. Adjusted Parameters')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 7))
plt.plot(temperatures, Ree_values, marker='o', linestyle='-', color='blue', label='Ree (Original Parameters)')
plt.plot(temperatures, Ree_values_adjusted, marker='x', linestyle='--', color='red', label='Ree (Adjusted Parameters)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('End-to-End Distance (Ree)')
plt.title('End-to-End Distance vs Temperature: Original vs. Adjusted Parameters')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 7))
plt.plot(temperatures, potential_energies_avg, marker='o', linestyle='-', color='blue', label='Avg Potential Energy (Original Parameters)')
plt.plot(temperatures, potential_energies_avg_adjusted, marker='x', linestyle='--', color='red', label='Avg Potential Energy (Adjusted Parameters)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('Average Potential Energy (Reduced Units)')
plt.title('Average Potential Energy vs Temperature: Original vs. Adjusted Parameters')
plt.legend()
plt.grid(True)
plt.show()

fig = plt.figure(figsize=(12, 6))

ax1 = fig.add_subplot(121, projection='3d')
ax1.scatter(positions_low_temp_adjusted[:, 0], positions_low_temp_adjusted[:, 1], positions_low_temp_adjusted[:, 2],
           color='red', s=50, label='Beads at Lowest Temp (Adjusted)')
for i in range(n_particles - 1):
    ax1.plot(positions_low_temp_adjusted[i:i+2, 0], positions_low_temp_adjusted[i:i+2, 1], positions_low_temp_adjusted[i:i+2, 2],
             color='gray', linestyle='-', linewidth=1)
ax1.set_title('Polymer Configuration at Lowest Temperature (Adjusted Parameters)')
ax1.set_xlabel('X')
ax1.set_ylabel('Y')
ax1.set_zlabel('Z')
ax1.view_init(elev=20, azim=-60)


ax2 = fig.add_subplot(122, projection='3d')
ax2.scatter(positions_high_temp_adjusted[:, 0], positions_high_temp_adjusted[:, 1], positions_high_temp_adjusted[:, 2],
           color='blue', s=50, label='Beads at Highest Temp (Adjusted)')
for i in range(n_particles - 1):
    ax2.plot(positions_high_temp_adjusted[i:i+2, 0], positions_high_temp_adjusted[i:i+2, 1], positions_high_temp_adjusted[i:i+2, 2],
             color='lightblue', linestyle='-', linewidth=1)
ax2.set_title('Polymer Configuration at Highest Temperature (Adjusted Parameters)')
ax2.set_xlabel('X')
ax2.set_ylabel('Y')
ax2.set_zlabel('Z')
ax2.view_init(elev=20, azim=-60)

plt.tight_layout()
plt.show()
