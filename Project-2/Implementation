import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Define Boltzmann constant for reduced units
k_B = 1.0

# 2. Implement apply_pbc function
def apply_pbc(position, box_size):
    return np.mod(position, box_size)

# 3. Implement minimum_image function
def minimum_image(displacement, box_size):
    return displacement - box_size * np.round(displacement / box_size)

# 4. Implement initialize_chain function
def initialize_chain(n_particles, box_size, r0):
    positions = np.zeros((n_particles, 3))
    current_position = np.array([box_size / 2, box_size / 2, box_size / 2])
    positions[0] = current_position
    for i in range(1, n_particles):
        direction = np.random.rand(3) - 0.5 # Random vector centered around zero
        direction = direction / np.linalg.norm(direction) # Normalize to unit vector
        next_position = current_position + r0 * direction
        positions[i] = apply_pbc(next_position, box_size)
        current_position = positions[i]
    return positions

# 5. Implement initialize_velocities function
def initialize_velocities(n_particles, target_temperature, mass):
    # Maxwell-Boltzmann distribution for velocities
    # The standard deviation is sqrt(k_B * T / m)
    scale = np.sqrt(k_B * target_temperature / mass)
    velocities = np.random.normal(scale=scale, size=(n_particles, 3))
    # Remove net momentum
    velocities -= np.mean(velocities, axis=0)
    return velocities

# 6. Implement compute_harmonic_forces function
def compute_harmonic_forces(positions, k, r0, box_size):
    n_particles = positions.shape[0]
    forces = np.zeros_like(positions)
    for i in range(n_particles - 1):
        displacement = positions[i+1] - positions[i]
        displacement = minimum_image(displacement, box_size)
        distance = np.linalg.norm(displacement)
        if distance == 0:
            continue # Avoid division by zero
        force_magnitude = -k * (distance - r0)
        force = force_magnitude * (displacement / distance)
        forces[i] -= force
        forces[i+1] += force
    return forces

# 7. Implement compute_lennard_jones_forces function
def compute_lennard_jones_forces(positions, epsilon_repulsive, epsilon_attractive, sigma, box_size, lj_cutoff):
    n_particles = positions.shape[0]
    forces = np.zeros_like(positions)
    lj_cutoff_repulsive_wca = (2**(1/6)) * sigma # WCA cutoff for 1-3 interactions

    for i in range(n_particles):
        for j in range(i + 1, n_particles):
            # Bonded particles (abs(i-j) == 1) are handled by harmonic forces
            if abs(i - j) == 1:
                continue

            displacement = positions[j] - positions[i]
            displacement = minimum_image(displacement, box_size)
            distance = np.linalg.norm(displacement)

            if distance == 0:
                continue # Avoid division by zero

            # Apply general LJ cutoff
            if distance < lj_cutoff:
                r_inv = 1.0 / distance
                r6 = (sigma * r_inv)**6
                r12 = r6**2

                force_magnitude = 0.0
                if abs(i - j) == 2: # 1-3 repulsive interactions
                    if distance < lj_cutoff_repulsive_wca:
                        # WCA potential derivative
                        force_magnitude = 24 * epsilon_repulsive * (2 * r12 - r6) * r_inv
                elif abs(i - j) > 2: # Non-bonded attractive interactions
                    # Full LJ potential derivative
                    force_magnitude = 24 * epsilon_attractive * (2 * r12 - r6) * r_inv

                if force_magnitude != 0.0:
                    force = force_magnitude * (displacement / distance)
                    forces[i] -= force
                    forces[j] += force
    return forces

# 8. Implement compute_total_forces function
def compute_total_forces(positions, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff):
    forces_harmonic = compute_harmonic_forces(positions, k, r0, box_size)
    forces_lj = compute_lennard_jones_forces(positions, epsilon_repulsive, epsilon_attractive, sigma, box_size, lj_cutoff)
    return forces_harmonic + forces_lj

# 9. Implement velocity_verlet function
def velocity_verlet(positions, velocities, forces, dt, mass, box_size, k, r0, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff):
    velocities_half = velocities + 0.5 * forces / mass * dt
    positions_new = positions + velocities_half * dt
    positions_new = apply_pbc(positions_new, box_size)

    # Need to compute new forces using the updated positions
    forces_new = compute_total_forces(positions_new, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff)

    velocities_new = velocities_half + 0.5 * forces_new / mass * dt
    return positions_new, velocities_new, forces_new

# 10. Implement rescale_velocities function
def rescale_velocities(velocities, target_temperature, mass, n_particles):
    kinetic_energy = 0.5 * mass * np.sum(np.linalg.norm(velocities, axis=1)**2)
    # For 3D particles, degrees of freedom = 3 * n_particles
    # Subtract 3 for center of mass velocity if removed, but typically (3/2)NkT for temperature def
    current_temperature = (2 / (3 * n_particles)) * kinetic_energy / k_B
    if current_temperature == 0: # Avoid division by zero
        return velocities # Cannot rescale if current_temperature is zero
    scaling_factor = np.sqrt(target_temperature / current_temperature)
    velocities_scaled = velocities * scaling_factor
    return velocities_scaled

# 11. Implement calculate_harmonic_potential_total function
def calculate_harmonic_potential_total(positions, k, r0, box_size):
    n_particles = positions.shape[0]
    total_U = 0.0
    for i in range(n_particles - 1):
        displacement = positions[i+1] - positions[i]
        displacement = minimum_image(displacement, box_size)
        distance = np.linalg.norm(displacement)
        total_U += 0.5 * k * (distance - r0)**2
    return total_U

# 12. Implement calculate_lj_potential_total function
def calculate_lj_potential_total(positions, epsilon_repulsive, epsilon_attractive, sigma, box_size, lj_cutoff_repulsive, lj_cutoff_attractive):
    n_particles = positions.shape[0]
    total_U = 0.0
    for i in range(n_particles):
        for j in range(i + 1, n_particles):
            if abs(i - j) == 1: # Bonded particles, handled by harmonic potential
                continue

            displacement = positions[j] - positions[i]
            displacement = minimum_image(displacement, box_size)
            distance = np.linalg.norm(displacement)

            if distance == 0:
                continue

            r_inv = 1.0 / distance
            r6 = (sigma * r_inv)**6
            r12 = r6**2

            if abs(i - j) == 2: # 1-3 repulsive interactions (WCA)
                if distance < lj_cutoff_repulsive:
                    # Shifted WCA potential (U_WCA(r) - U_WCA(r_cutoff) - (r - r_cutoff)*dU_WCA/dr|_r_cutoff)
                    # The pseudocode implies just U_WCA(r) - U_WCA(r_cutoff), and U_WCA(r_cutoff)=epsilon_repulsive
                    total_U += 4 * epsilon_repulsive * (r12 - r6) + epsilon_repulsive
            elif abs(i - j) > 2: # Non-bonded attractive interactions
                if distance < lj_cutoff_attractive:
                    total_U += 4 * epsilon_attractive * (r12 - r6)
    return total_U

# Lists to store collected data
Rg_values = []
Ree_values = []
potential_energies_avg = []

# 13. Implement calculate_total_potential_energy function
def calculate_total_potential_energy(positions, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma, lj_cutoff_repulsive, lj_cutoff_attractive):
    U_harmonic = calculate_harmonic_potential_total(positions, k, r0, box_size)
    U_lj = calculate_lj_potential_total(positions, epsilon_repulsive, epsilon_attractive, sigma, box_size, lj_cutoff_repulsive, lj_cutoff_attractive)
    return U_harmonic + U_lj

# 14. Implement calculate_radius_of_gyration function
def calculate_radius_of_gyration(positions):
    center_of_mass = np.mean(positions, axis=0)
    Rg_squared = np.mean(np.sum((positions - center_of_mass)**2, axis=1))
    Rg = np.sqrt(Rg_squared)
    return Rg

# 15. Implement calculate_end_to_end_distance function
def calculate_end_to_end_distance(positions):
    Ree = np.linalg.norm(positions[-1] - positions[0])
    return Ree

# Simulation parameters
dt = 0.01  # Time step
total_simulation_steps = 10000  # Total number of simulation steps for each temperature run
equilibration_steps = 2000  # Number of steps for equilibration before data collection
box_size = 100.0  # Size of the cubic box
k = 1.0  # Spring constant
mass = 1.0  # Particle mass
r0 = 1.0  # Equilibrium bond length
n_particles = 20  # Number of particles
epsilon_repulsive = 1.0  # Depth of repulsive LJ potential
epsilon_attractive = 0.5  # Depth of attractive LJ potential
sigma = 1.0  # LJ potential parameter

# Lennard-Jones cutoff distances
lj_force_cutoff = 2.5 * sigma  # Cutoff distance for Lennard-Jones forces
lj_potential_cutoff_repulsive = (2**(1/6)) * sigma  # Cutoff for repulsive 1-3 LJ potential energy (WCA)
lj_potential_cutoff_attractive = 2.5 * sigma # Cutoff for attractive non-bonded LJ potential energy

rescale_interval = 100  # Steps between velocity rescaling
temperatures = np.linspace(0.1, 1.0, 10)  # Array of target temperatures

for T in temperatures:
    target_temperature = T

    # Re-initialize positions and velocities for each temperature run
    positions = initialize_chain(n_particles, box_size, r0)
    velocities = initialize_velocities(n_particles, target_temperature, mass)

    # Initial forces calculation
    forces = compute_total_forces(positions, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma, lj_force_cutoff)

    # List to store potential energy during data collection phase
    potential_energy_per_step = []

    # Main simulation loop for the current temperature
    for step in range(total_simulation_steps):
        # Integrate equations of motion using Velocity Verlet
        positions, velocities, forces = velocity_verlet(
            positions, velocities, forces, dt, mass, box_size,
            k, r0, epsilon_repulsive, epsilon_attractive, sigma, lj_force_cutoff
        )

        # Apply thermostat (velocity rescaling)
        if step % rescale_interval == 0:
            velocities = rescale_velocities(velocities, target_temperature, mass, n_particles)

        # Data collection after equilibration
        if step >= equilibration_steps:
            current_potential_energy = calculate_total_potential_energy(
                positions, k, r0, box_size, epsilon_repulsive, epsilon_attractive, sigma,
                lj_potential_cutoff_repulsive, lj_potential_cutoff_attractive
            )
            potential_energy_per_step.append(current_potential_energy)

    # After simulation for current temperature, compute properties
    Rg = calculate_radius_of_gyration(positions)
    Ree = calculate_end_to_end_distance(positions)

    Rg_values.append(Rg)
    Ree_values.append(Ree)
    potential_energies_avg.append(np.mean(potential_energy_per_step))

# Plot Radius of Gyration vs Temperature
plt.figure(figsize=(8, 6))
plt.plot(temperatures, Rg_values, marker='o', linestyle='-', color='blue', label='Radius of Gyration (Rg)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('Radius of Gyration (Rg)')
plt.title('Radius of Gyration vs Temperature')
plt.legend()
plt.grid(True)
plt.show()

# Plot End-to-End Distance vs Temperature
plt.figure(figsize=(8, 6))
plt.plot(temperatures, Ree_values, marker='o', linestyle='-', color='green', label='End-to-End Distance (Ree)')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('End-to-End Distance (Ree)')
plt.title('End-to-End Distance vs Temperature')
plt.legend()
plt.grid(True)
plt.show()

# Plot Average Potential Energy vs Temperature
plt.figure(figsize=(8, 6))
plt.plot(temperatures, potential_energies_avg, marker='o', linestyle='-', color='red', label='Average Potential Energy')
plt.xlabel('Temperature (Reduced Units)')
plt.ylabel('Average Potential Energy (Reduced Units)')
plt.title('Average Potential Energy vs Temperature')
plt.legend()
plt.grid(True)
plt.show()
